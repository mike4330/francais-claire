<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>French Listening Practice</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            max-width: 1040px;
            width: 100%;
            text-align: center;
            position: relative;
        }

        .header {
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.2em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .aws-config {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 3px solid #ff9500;
        }

        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            margin-bottom: 15px;
        }

        .config-header h3 {
            color: #333;
            font-size: 1.1em;
            margin: 0;
        }

        .config-toggle-btn {
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            transition: transform 0.3s ease;
            color: #667eea;
        }

        .config-toggle-btn.collapsed {
            transform: rotate(-90deg);
        }

        .config-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .config-content.collapsed {
            max-height: 0;
        }

        .config-summary {
            display: none;
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }

        .config-summary.show {
            display: block;
        }

        .config-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .config-row input, .config-row select {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .config-row label {
            min-width: 80px;
            text-align: left;
            font-weight: 500;
            color: #555;
        }

        .config-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .config-status {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .config-status.ready {
            background: #d4edda;
            color: #155724;
        }

        .config-status.not-ready {
            background: #f8d7da;
            color: #721c24;
        }

        .question-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            border-left: 5px solid #667eea;
        }

        .question-number {
            color: #667eea;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .question-id {
            font-size: 0.75em;
            color: #999;
            font-weight: normal;
            opacity: 0.7;
        }

        .audio-controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            align-items: center;
        }

        .play-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .play-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .play-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 8px 15px;
            border-radius: 25px;
            border: 2px solid #e9ecef;
        }

        .speed-control select {
            border: none;
            background: transparent;
            font-size: 0.9em;
            cursor: pointer;
        }

        .question-text {
            font-size: 1.2em;
            color: #333;
            margin: 20px 0;
            font-weight: 500;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 25px 0;
            text-align: left;
        }

        .option {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .option.selected {
            border-color: #667eea;
            background: linear-gradient(45deg, #667eea0a, #764ba20a);
        }

        .option.correct {
            border-color: #28a745;
            background: #d4edda;
        }

        .option.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .option-letter {
            display: inline-block;
            width: 25px;
            height: 25px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            font-weight: bold;
            margin-right: 12px;
            font-size: 0.9em;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
            gap: 15px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            opacity: 0.9;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .progress {
            background: #e9ecef;
            border-radius: 10px;
            height: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(45deg, #667eea, #764ba2);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .score {
            margin-top: 20px;
            font-size: 1.1em;
            color: #333;
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 500;
        }

        .feedback.correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .feedback.incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .container {
                padding: 25px;
                margin: 10px;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .audio-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .config-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .config-row label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }

        .hamburger-menu {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }
        .hamburger-btn {
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: box-shadow 0.2s;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            padding: 0;
            position: relative;
        }
        .hamburger-btn:focus {
            outline: 2px solid #764ba2;
        }
        .hamburger-btn .bar {
            display: block;
            width: 22px;
            height: 3px;
            margin: 3px 0;
            background: #fff;
            border-radius: 2px;
            transition: all 0.3s;
        }
        .menu-dropdown {
            display: none;
            position: absolute;
            top: 48px;
            right: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.18);
            min-width: 180px;
            padding: 10px 0;
            flex-direction: column;
            z-index: 200;
            animation: fadeIn 0.2s;
        }
        .menu-dropdown a {
            display: block;
            padding: 12px 24px;
            color: #333;
            text-decoration: none;
            font-size: 1.05em;
            transition: background 0.15s, color 0.15s;
        }
        .menu-dropdown a:hover {
            background: #f3f4fa;
            color: #764ba2;
        }
        .hamburger-menu.open .menu-dropdown {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #questionTypeIcon {
            min-width: 175px;
            height: 120px;
            /* border: 4px solid #764ba2; */
            border-radius: 6px;
            background: #f8f9fa;
            
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4.5em;
            color: #764ba2;
            margin-bottom: 8px;
            margin-right: 0;
            box-sizing: border-box;
            box-shadow: 0 6px 24px rgba(102, 126, 234, 0.18), 0 1.5px 6px rgba(0,0,0,0.07);
            padding-left: 18px;
            padding-right: 18px;
        }
        @media (max-width: 768px) {
            #questionTypeIcon {
                width: 80px;
                height: 80px;
                font-size: 2.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Hamburger Menu -->
        <div class="hamburger-menu" id="hamburgerMenu">
            <button class="hamburger-btn" id="hamburgerBtn" title="Menu" aria-label="Open menu">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </button>
            <div class="menu-dropdown" id="menuDropdown">
                <a href="student.html">👤 Student Dashboard</a>
                <a href="planning.html">🗂️ Planning & Management</a>
            </div>
        </div>
        
        <div class="header">
            <h1>🇫🇷 French Listening Practice</h1>
            <p>Improve your French listening skills with interactive exercises</p>
        </div>

        <!-- Difficulty Level Selection -->
        <div class="aws-config" style="border-left-color: #667eea;">
            <div class="config-header" onclick="toggleDifficultyConfig()">
                <h3>📊 Difficulty Level</h3>
                <button class="config-toggle-btn" id="difficultyToggleBtn">🔽</button>
            </div>
            <div class="config-summary" id="difficultySummary">
                Current: A1 Beginner (3 questions available)
            </div>
            <div class="config-content" id="difficultyContent">
                <div style="margin-bottom: 15px;">
                    <label style="font-weight: 500; color: #333; display: block; margin-bottom: 10px;">
                        Select your target level:
                    </label>
                    <div id="difficultyButtons" style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <!-- Difficulty buttons will be populated by JavaScript -->
                    </div>
                </div>

            </div>
        </div>

        <!-- AWS Polly Configuration -->
        <div class="aws-config">
            <div class="config-header" onclick="toggleConfig()">
                <h3>🔧 AWS Polly Configuration</h3>
                <button class="config-toggle-btn" id="configToggleBtn">🔽</button>
            </div>
            <div class="config-summary" id="configSummary">
                Using Polly with Céline voice in us-east-1
            </div>
            <div class="config-content collapsed" id="configContent">
                <div class="config-toggle">
                    <input type="checkbox" id="usePolly" checked>
                    <label for="usePolly">Use Amazon Polly (uncheck for browser TTS fallback)</label>
                </div>
                <div id="pollyConfig">
                    <div class="config-row">
                        <label>Access Key:</label>
                        <input type="text" id="awsAccessKey" placeholder="Your AWS Access Key ID">
                    </div>
                    <div class="config-row">
                        <label>Secret Key:</label>
                        <input type="password" id="awsSecretKey" placeholder="Your AWS Secret Access Key">
                    </div>
                    <div class="config-row">
                        <label>Region:</label>
                        <select id="awsRegion">
                            <option value="us-east-1">US East (N. Virginia)</option>
                            <option value="us-west-2">US West (Oregon)</option>
                            <option value="eu-west-1">Europe (Ireland)</option>
                            <option value="eu-central-1">Europe (Frankfurt)</option>
                            <option value="ap-southeast-2">Asia Pacific (Sydney)</option>
                        </select>
                    </div>
                    <div class="config-row">
                        <label>Voice:</label>
                        <select id="pollyVoice">
                            <option value="Celine">Céline (Female, French)</option>
                            <option value="Mathieu">Mathieu (Male, French)</option>
                            <option value="Lea">Léa (Female, French)</option>
                        </select>
                    </div>
                    <div class="config-status" id="configStatus">
                        ⚠️ Please configure AWS credentials
                    </div>
                    <div style="margin-top: 15px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                            <button class="btn btn-secondary" onclick="clearSettings()" style="font-size: 0.9em; padding: 8px 15px;">
                                🗑️ Clear Settings
                            </button>
                            <button class="btn btn-secondary" onclick="preCacheAllQuestions()" style="font-size: 0.9em; padding: 8px 15px;">
                                🔄 Pre-Cache All
                            </button>
                            <button class="btn btn-secondary" onclick="clearRedisCache()" style="font-size: 0.9em; padding: 8px 15px;">
                                🗑️ Clear Redis Cache
                            </button>
                            <button class="btn btn-secondary" onclick="regenerateVariations()" style="font-size: 0.9em; padding: 8px 15px;">
                                🎲 New Variations
                            </button>
                            <button class="btn btn-secondary" id="cacheStatsBtn" style="font-size: 0.9em; padding: 8px 15px; cursor: default;" disabled>
                                📊 Redis: Connecting...
                            </button>
                        </div>
                        <div id="cacheStatus" class="config-status not-ready" style="margin-bottom: 10px;">
                            Connecting to Redis cache server...
                        </div>
                        <small style="color: #666;">Audio cached in Redis via WebSocket • Automatic caching enabled • Settings auto-saved</small>
                    </div>
                </div>
            </div>
        </div>

        <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <div class="question-container">
            <div class="question-number" id="questionNumber">
                <span>Question 1 of 5</span>
                <span class="question-id" id="questionId">ID: #1</span>
            </div>
            <div class="question-text" id="questionText">
                What did you hear?
            </div>
            <div style="display: flex; align-items: flex-start; gap: 28px; margin-bottom: 10px;">
                <div id="questionTypeIcon" style="width: 150px;"></div>
                <div style="flex:1;">
                    <div class="audio-controls">
                        <button class="play-btn" id="playBtn">
                            <span>▶️</span> Play Audio
                        </button>
                        <div class="speed-control">
                            <label>Speed:</label>
                            <select id="speedSelect">
                                <option value="0.75">0.75x</option>
                                <option value="0.9" selected>0.9x</option>
                                <option value="1">1x</option>
                                <option value="1.1">1.1x</option>
                                <option value="1.25">1.25x</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="options" id="optionsContainer">
                <!-- Options will be populated by JavaScript -->
            </div>
            <div class="feedback" id="feedback" style="display: none;"></div>
        </div>

        <div class="controls">
            <button class="btn btn-secondary" id="prevBtn" disabled>Previous</button>
            <button class="btn btn-secondary" id="skipBtn">Skip Question</button>
            <button class="btn btn-primary" id="submitBtn" disabled>Submit Answer</button>
            <button class="btn btn-secondary" id="nextBtn" disabled>Next</button>
        </div>

        <div class="score" id="scoreDisplay">Score: 0/0</div>
    </div>

    <!-- AWS SDK -->
    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1691.0.min.js"></script>
    <script src="function.js"></script>

    <script>
        // --- User UUID Cookie Logic ---
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
        }
        function setCookie(name, value, days) {
            let expires = '';
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days*24*60*60*1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "")  + expires + "; path=/";
        }
        function generateUUIDv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        // Set UUID cookie if not present
        let userUUID = getCookie('french_listening_uuid');
        if (!userUUID) {
            userUUID = generateUUIDv4();
            setCookie('french_listening_uuid', userUUID, 730); // 2 years
        }
        // --- End User UUID Cookie Logic ---

        // French News Listening Training System
        // Difficulty levels: A1 (basic) -> C2 (advanced news)
        const DIFFICULTY_LEVELS = {
            'A1': { name: 'Beginner', color: '#28a745', description: 'Simple phrases, basic vocabulary' },
            'A2': { name: 'Elementary', color: '#20c997', description: 'Everyday expressions, personal topics' },
            'B1': { name: 'Intermediate', color: '#fd7e14', description: 'Work, travel, familiar topics' },
            'B2': { name: 'Upper-Intermediate', color: '#e83e8c', description: 'Abstract topics, complex ideas' },
            'C1': { name: 'Advanced', color: '#6f42c1', description: 'Professional, academic content' },
            'C2': { name: 'C2 - Proficiency', color: '#dc3545', description: 'French news, media, complex discourse' }
        };

        // Question bank loaded from external JSON file
        let questionBank = [];

        // Current session questions (filtered by difficulty)
        let questions = [];
        let currentDifficulty = 'A1';

        // App state
        let currentQuestion = 0;
        let selectedAnswer = null;
        let score = 0;
        let answered = false;
        let userAnswers = [];

        // AWS Polly configuration
        let polly = null;
        let currentAudio = null;

        // Settings persistence
        const SETTINGS_KEY = 'french-listening-polly-settings';
        const QUESTION_BANK_KEY = 'french-listening-question-bank';

        // DOM elements
        const questionNumberEl = document.getElementById('questionNumber');
        const questionTextEl = document.getElementById('questionText');
        const optionsContainer = document.getElementById('optionsContainer');
        const playBtn = document.getElementById('playBtn');
        const speedSelect = document.getElementById('speedSelect');
        const submitBtn = document.getElementById('submitBtn');
        const skipBtn = document.getElementById('skipBtn');
        const nextBtn = document.getElementById('nextBtn');
        const prevBtn = document.getElementById('prevBtn');
        const progressBar = document.getElementById('progressBar');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const feedback = document.getElementById('feedback');

        // AWS Config elements
        const usePollyCheckbox = document.getElementById('usePolly');
        const pollyConfigDiv = document.getElementById('pollyConfig');
        const awsAccessKeyInput = document.getElementById('awsAccessKey');
        const awsSecretKeyInput = document.getElementById('awsSecretKey');
        const awsRegionSelect = document.getElementById('awsRegion');
        const pollyVoiceSelect = document.getElementById('pollyVoice');
        const configStatusEl = document.getElementById('configStatus');
        const configToggleBtn = document.getElementById('configToggleBtn');
        const configContent = document.getElementById('configContent');
        const configSummary = document.getElementById('configSummary');

        // Difficulty system elements
        const difficultyToggleBtn = document.getElementById('difficultyToggleBtn');
        const difficultyContent = document.getElementById('difficultyContent');
        const difficultySummary = document.getElementById('difficultySummary');
        const difficultyButtons = document.getElementById('difficultyButtons');

        // Hamburger menu toggle logic
        const hamburgerBtn = document.getElementById('hamburgerBtn');
        const menuDropdown = document.getElementById('menuDropdown');
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        hamburgerBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            hamburgerMenu.classList.toggle('open');
        });
        document.addEventListener('click', function(e) {
            if (!hamburgerMenu.contains(e.target)) {
                hamburgerMenu.classList.remove('open');
            }
        });

        // AWS Polly Setup
        function initializePolly() {
            if (!usePollyCheckbox.checked) {
                updateConfigStatus('Browser TTS mode', 'ready');
                return true;
            }

            const accessKey = awsAccessKeyInput.value.trim();
            const secretKey = awsSecretKeyInput.value.trim();
            const region = awsRegionSelect.value;

            if (!accessKey || !secretKey) {
                updateConfigStatus('Please configure AWS credentials', 'not-ready');
                return false;
            }

            try {
                AWS.config.update({
                    accessKeyId: accessKey,
                    secretAccessKey: secretKey,
                    region: region
                });

                polly = new AWS.Polly();
                updateConfigStatus('AWS Polly configured successfully', 'ready');
                return true;
            } catch (error) {
                console.error('AWS configuration error:', error);
                updateConfigStatus('AWS configuration error', 'not-ready');
                return false;
            }
        }

        function updateConfigStatus(message, status) {
            configStatusEl.textContent = message;
            configStatusEl.className = `config-status ${status}`;
            updateConfigSummary();
        }

        function updateConfigSummary() {
            const isPollyEnabled = usePollyCheckbox.checked;
            const voice = pollyVoiceSelect.value;
            const region = awsRegionSelect.value;
            const hasCredentials = awsAccessKeyInput.value.trim() && awsSecretKeyInput.value.trim();
            
            if (!isPollyEnabled) {
                configSummary.textContent = "Using browser TTS fallback";
            } else if (hasCredentials) {
                configSummary.textContent = `Using Polly with ${voice} voice in ${region}`;
            } else {
                configSummary.textContent = "Polly enabled but credentials needed";
            }
        }

        // Settings persistence functions
        function saveSettings() {
            if (!window.localStorage) return;
            
            const settings = {
                usePolly: usePollyCheckbox.checked,
                accessKey: awsAccessKeyInput.value,
                secretKey: awsSecretKeyInput.value,
                region: awsRegionSelect.value,
                voice: pollyVoiceSelect.value,
                configCollapsed: configContent.classList.contains('collapsed')
            };
            
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
            } catch (error) {
                console.warn('Could not save settings to localStorage:', error);
            }
        }

        function loadSettings() {
            if (!window.localStorage) return;
            
            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (!saved) return;
                
                const settings = JSON.parse(saved);
                
                // Restore form values
                if (settings.usePolly !== undefined) usePollyCheckbox.checked = settings.usePolly;
                if (settings.accessKey) awsAccessKeyInput.value = settings.accessKey;
                if (settings.secretKey) awsSecretKeyInput.value = settings.secretKey;
                if (settings.region) awsRegionSelect.value = settings.region;
                if (settings.voice) pollyVoiceSelect.value = settings.voice;
                
                // Restore collapsed state
                if (settings.configCollapsed) {
                    configContent.classList.add('collapsed');
                    configToggleBtn.classList.add('collapsed');
                    configToggleBtn.textContent = '▶️';
                    configSummary.classList.add('show');
                }
                
                // Re-initialize Polly with loaded settings
                initializePolly();
                
            } catch (error) {
                console.warn('Could not load settings from localStorage:', error);
            }
        }

        function clearSettings() {
            if (!window.localStorage) return;
            
            try {
                localStorage.removeItem(SETTINGS_KEY);
                
                // Reset form to defaults
                usePollyCheckbox.checked = true;
                awsAccessKeyInput.value = '';
                awsSecretKeyInput.value = '';
                awsRegionSelect.value = 'us-east-1';
                pollyVoiceSelect.value = 'Celine';
                
                // Expand config panel
                configContent.classList.remove('collapsed');
                configToggleBtn.classList.remove('collapsed');
                configToggleBtn.textContent = '🔽';
                configSummary.classList.remove('show');
                
                // Re-initialize
                initializePolly();
                
                alert('Settings cleared successfully!');
            } catch (error) {
                console.warn('Could not clear settings:', error);
            }
        }

        // Redis cache management functions
        async function updateCacheStats() {
            try {
                const result = await sendCacheMessage({ action: 'get_stats' });
                const btn = document.getElementById('cacheStatsBtn');
                if (btn) {
                    btn.textContent = `📊 Redis: ${result.count} files (${result.sizeMB}MB)`;
                }
            } catch (error) {
                console.warn('❌ Failed to get cache stats:', error.message);
            }
        }

        async function clearRedisCache() {
            if (!confirm('Clear all cached audio files from Redis? This will require re-downloading from Polly.')) {
                return;
            }
            
            try {
                const result = await sendCacheMessage({ action: 'clear_cache' });
                alert(`Cleared ${result.cleared} cached audio files from Redis.`);
                updateCacheStats();
            } catch (error) {
                console.error('❌ Failed to clear cache:', error.message);
                alert('Failed to clear cache. Check console for details.');
            }
        }

        // Surgically evict a specific question from cache
        async function evictQuestionFromCache(questionId) {
            const question = questionBank.find(q => q.id === questionId);
            if (!question) {
                console.error(`❌ Question ${questionId} not found`);
                return false;
            }

            const voiceId = pollyVoiceSelect.value;
            
            try {
                const result = await sendCacheMessage({ 
                    action: 'evict_cache',
                    text: question.audioText,
                    voiceId: voiceId
                });
                
                if (result.evicted) {
                    console.log(`✅ Question ${questionId} evicted from cache`);
                    updateCacheStats();
                    return true;
                } else {
                    console.log(`ℹ️ Question ${questionId} was not in cache`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Failed to evict question ${questionId}:`, error.message);
                return false;
            }
        }

        // Convenience function to evict question 9 specifically
        async function evictQuestion9() {
            const result = await evictQuestionFromCache(9);
            if (result) {
                alert('Question 9 has been surgically evicted from cache! Next play will use fresh SSML synthesis.');
            } else {
                alert('Question 9 was not found in cache (or eviction failed).');
            }
        }

        // Regenerate template variations for all questions
        function regenerateVariations() {
            let regeneratedCount = 0;
            
            // Clear existing generated variations and timestamps
            questionBank.forEach(question => {
                if (question.audioTemplate && question.templateVariables) {
                    delete question._generatedVariation;
                    delete question._variationTimestamp;
                    regeneratedCount++;
                }
            });
            
            // If we're currently viewing a template-enabled question, reload it
            if (questions.length > 0 && currentQuestion < questions.length) {
                const currentQ = questions[currentQuestion];
                if (currentQ.audioTemplate && currentQ.templateVariables) {
                    loadQuestion();
                }
            }
            
            if (regeneratedCount > 0) {
                console.log(`🎲 Regenerated variations for ${regeneratedCount} template-enabled questions`);
                alert(`Generated new variations for ${regeneratedCount} questions! Play audio to hear the changes.`);
            } else {
                alert('No template-enabled questions found in current question bank.');
            }
        }

        async function preCacheAllQuestions() {
            if (!polly || !usePollyCheckbox.checked) {
                alert('Please configure AWS Polly first!');
                return;
            }

            if (!cacheSocket || cacheSocket.readyState !== WebSocket.OPEN) {
                alert('Redis cache server not connected!');
                return;
            }

            const btn = event.target;
            const originalText = btn.textContent;
            
            try {
                btn.disabled = true;
                btn.textContent = '🔄 Caching...';
                
                const voiceId = pollyVoiceSelect.value;
                let cached = 0;
                let total = questionBank.length;
                
                for (let i = 0; i < questionBank.length; i++) {
                    const question = questionBank[i];
                    
                    // Check if already cached in Redis
                    const existing = await getCachedAudio(question.audioText, voiceId);
                    if (existing) {
                        console.log(`✅ Already cached: ${question.audioText.substring(0, 30)}...`);
                        continue;
                    }
                    
                    // Generate and cache
                    btn.textContent = `🔄 Caching ${i + 1}/${total}...`;
                    
                    try {
                        await synthesizeWithPolly(question.audioText);
                        cached++;
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 500));
                    } catch (error) {
                        console.error(`❌ Failed to cache question ${question.id}:`, error);
                    }
                }
                
                updateCacheStats();
                alert(`Pre-caching complete! ${cached} new audio files stored in Redis.`);
                
            } catch (error) {
                console.error('❌ Pre-cache error:', error);
                alert('Pre-caching failed. Check console for details.');
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // Initialize cache UI on load
        function initializeCacheUI() {
            initializeCacheSocket();
            // Initial stats update after connection
            setTimeout(updateCacheStats, 2000);
        }

        function toggleConfig() {
            const isCollapsed = configContent.classList.contains('collapsed');
            
            if (isCollapsed) {
                // Expand
                configContent.classList.remove('collapsed');
                configToggleBtn.classList.remove('collapsed');
                configToggleBtn.textContent = '🔽';
                configSummary.classList.remove('show');
            } else {
                // Collapse
                configContent.classList.add('collapsed');
                configToggleBtn.classList.add('collapsed');
                configToggleBtn.textContent = '▶️';
                configSummary.classList.add('show');
            }
            
            // Save the collapsed state
            saveSettings();
        }

        // WebSocket Redis Cache Integration
        let cacheSocket = null;
        let cachePromises = new Map(); // Track pending cache operations

        // Initialize WebSocket connection to Redis cache server
        function initializeCacheSocket() {
            try {
                cacheSocket = new WebSocket('ws://localhost:8080');
                
                cacheSocket.onopen = () => {
                    console.log('✅ Connected to Redis cache server');
                    updateCacheStatus('Connected to Redis cache', 'ready');
                };
                
                cacheSocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    // Create a truncated version for logging (omit large audioData)
                    const logData = { ...data };
                    if (logData.audioData) {
                        logData.audioData = `[${logData.audioData.length} bytes]`;
                    }
                    console.log('📨 Received cache message:', logData);
                    handleCacheMessage(data);
                };
                
                cacheSocket.onclose = () => {
                    console.log('❌ Disconnected from Redis cache server');
                    updateCacheStatus('Redis cache disconnected', 'not-ready');
                    // Attempt reconnection after 5 seconds
                    setTimeout(initializeCacheSocket, 5000);
                };
                
                cacheSocket.onerror = (error) => {
                    console.error('❌ Cache WebSocket error:', error);
                    updateCacheStatus('Redis cache error', 'not-ready');
                };
            } catch (error) {
                console.error('❌ Failed to connect to cache server:', error);
                updateCacheStatus('Cache server unavailable', 'not-ready');
            }
        }

        function updateCacheStatus(message, status) {
            // Update UI to show cache status
            const statusEl = document.getElementById('cacheStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `config-status ${status}`;
            }
        }

        function handleCacheMessage(data) {
            const { type } = data;
            
            // Find matching promise by comparing the original message
            let matchingKey = null;
            
            for (const [key, promiseData] of cachePromises.entries()) {
                const { message } = promiseData;
                
                if ((type === 'cache_check_result' && message.action === 'check_cache') ||
                    (type === 'cache_store_result' && message.action === 'store_cache') ||
                    (type === 'stats_result' && message.action === 'get_stats') ||
                    (type === 'clear_cache_result' && message.action === 'clear_cache') ||
                    (type === 'evict_cache_result' && message.action === 'evict_cache')) {
                    matchingKey = key;
                    break;
                }
            }
            
            if (matchingKey) {
                const { resolve } = cachePromises.get(matchingKey);
                resolve(data);
                cachePromises.delete(matchingKey);
            } else {
                console.log('⚠️ No matching promise found for:', type);
            }
        }

        function sendCacheMessage(message) {
            return new Promise((resolve, reject) => {
                if (!cacheSocket || cacheSocket.readyState !== WebSocket.OPEN) {
                    reject(new Error('Cache server not connected'));
                    return;
                }
                
                // Create a unique key using text and voice for cache operations
                let promiseKey;
                if (message.text && message.voiceId) {
                    promiseKey = `${message.action}_${message.text}_${message.voiceId}`;
                } else {
                    promiseKey = `${message.action}_${Date.now()}`;
                }
                
                cachePromises.set(promiseKey, { resolve, reject, message });
                
                console.log('📤 Sending cache message:', message);
                cacheSocket.send(JSON.stringify(message));
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    if (cachePromises.has(promiseKey)) {
                        cachePromises.delete(promiseKey);
                        reject(new Error('Cache operation timeout'));
                    }
                }, 10000);
            });
        }

        // Generate cache key for audio files
        function generateCacheKey(text, voiceId) {
            // Use same MD5 approach as server
            return btoa(text + '_' + voiceId).replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);
        }

        // Check if cached audio exists in Redis
        async function getCachedAudio(text, voiceId, speed = 1.0) {
            try {
                const result = await sendCacheMessage({
                    action: 'check_cache',
                    text: text,
                    voiceId: voiceId
                });
                
                if (result.exists && result.audioData) {
                    // Convert base64 back to audio blob
                    const binaryString = atob(result.audioData);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const audioBlob = new Blob([bytes], { type: 'audio/mpeg' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    audio.playbackRate = speed;
                    return audio;
                }
                return null;
            } catch (error) {
                console.log('❌ Cache check failed:', error.message);
                return null;
            }
        }

        // Save audio to Redis cache
        async function saveToCache(audioBlob, text, voiceId) {
            try {
                // Convert blob to base64
                const arrayBuffer = await audioBlob.arrayBuffer();
                const byteArray = new Uint8Array(arrayBuffer);
                let binaryString = '';
                for (let i = 0; i < byteArray.length; i++) {
                    binaryString += String.fromCharCode(byteArray[i]);
                }
                const base64Data = btoa(binaryString);
                
                await sendCacheMessage({
                    action: 'store_cache',
                    text: text,
                    voiceId: voiceId,
                    audioData: base64Data
                });
                
                console.log(`💾 Cached audio in Redis: ${text.substring(0, 30)}...`);
                updateCacheStats();
            } catch (error) {
                console.warn('❌ Failed to cache audio:', error.message);
            }
        }

        // Audio synthesis with Polly and Redis caching
        async function synthesizeWithPolly(text, speed = 1.0, ssml = null) {
            if (!polly) {
                throw new Error('Polly not configured');
            }

            const voiceId = pollyVoiceSelect.value;
            
            // Use SSML if provided, otherwise use plain text
            const audioContent = ssml || text;
            const textType = ssml ? 'ssml' : 'text';
            
            if (ssml) {
                console.log('🎤 SSML detected - using enhanced speech synthesis');
            }
            
            // Try to get from Redis cache first (use original text for cache key)
            const cachedAudio = await getCachedAudio(text, voiceId, speed);
            if (cachedAudio) {
                console.log(`✅ Using cached audio for: ${text.substring(0, 30)}...`);
                return cachedAudio;
            }

            // Cache miss - synthesize with Polly
            console.log(`🔊 Synthesizing with Polly (${textType}): ${text.substring(0, 30)}...`);
            const params = {
                Text: audioContent,
                TextType: textType,
                OutputFormat: 'mp3',
                VoiceId: voiceId,
                Engine: 'neural' // Use neural engine for better quality
            };

            try {
                const data = await polly.synthesizeSpeech(params).promise();
                const audioBlob = new Blob([data.AudioStream], { type: 'audio/mpeg' });
                
                // Save to Redis cache (use original text for cache key)
                await saveToCache(audioBlob, text, voiceId);
                
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                audio.playbackRate = speed;
                
                return audio;
            } catch (error) {
                console.error('❌ Polly synthesis error:', error);
                throw error;
            }
        }

        // Fallback to browser TTS
        function synthesizeWithBrowser(text, speed = 1.0) {
            return new Promise((resolve, reject) => {
                if (!window.speechSynthesis) {
                    reject(new Error('Browser TTS not supported'));
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'fr-FR';
                utterance.rate = speed;

                utterance.onend = () => resolve();
                utterance.onerror = (error) => reject(error);

                speechSynthesis.speak(utterance);
            });
        }

        // Play audio function
        async function playAudio() {
            const question = questions[currentQuestion];
            const speed = parseFloat(speedSelect.value);
            
            // Get the appropriate audio text (template variation or static)
            const audioText = getAudioTextForQuestion(question);
            
            // Stop any current audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            if (window.speechSynthesis) {
                speechSynthesis.cancel();
            }
            
            // Update button state
            playBtn.disabled = true;
            playBtn.innerHTML = '<span>🔊</span> Playing...';
            
            try {
                if (usePollyCheckbox.checked && polly) {
                    // Use Amazon Polly with SSML support (using generated audio text)
                    currentAudio = await synthesizeWithPolly(audioText, speed, question.ssml);
                    
                    currentAudio.onended = () => {
                        playBtn.disabled = false;
                        playBtn.innerHTML = '<span>▶️</span> Play Audio';
                        currentAudio = null;
                    };
                    
                    currentAudio.onerror = () => {
                        playBtn.disabled = false;
                        playBtn.innerHTML = '<span>▶️</span> Play Audio';
                        alert('Audio playback error occurred.');
                    };
                    
                    await currentAudio.play();
                } else {
                    // Fallback to browser TTS (uses generated text)
                    await synthesizeWithBrowser(audioText, speed);
                    playBtn.disabled = false;
                    playBtn.innerHTML = '<span>▶️</span> Play Audio';
                }
            } catch (error) {
                console.error('Audio playback error:', error);
                playBtn.disabled = false;
                playBtn.innerHTML = '<span>▶️</span> Play Audio';
                alert(`Audio playback failed: ${error.message}`);
            }
        }

        // Initialize app
        async function init() {
            await loadQuestionBankMulti(); // Load questions from multiple JSON files
            setupDifficultyButtons();
            filterQuestionsByDifficulty();
            loadSettings(); // Load saved settings first
            loadQuestion();
            updateProgress();
            updateScore();
            // initializePolly() is called by loadSettings()
        }

        // Question bank management
        async function loadQuestionBankMulti(files = ['questions.json', 'questions-a.json', 'questions-b.json', 'questions-c.json']) {
            try {
                console.log('Loading question files:', files);
                
                // Fetch all files in parallel
                const responses = await Promise.all(files.map(f => fetch(f)));
                const datas = await Promise.all(responses.map(async (r, index) => {
                    if (r.ok) {
                        try {
                            const data = await r.json();
                            const questionCount = data.questions ? data.questions.length : 0;
                            console.log(`✅ ${files[index]}: ${questionCount} questions loaded`);
                            return data;
                        } catch (error) {
                            console.warn(`❌ ${files[index]}: JSON parse error -`, error);
                            return { questions: [] };
                        }
                    } else {
                        console.warn(`❌ ${files[index]}: HTTP ${r.status} - ${r.statusText}`);
                        return { questions: [] };
                    }
                }));
                
                // Merge all questions arrays
                questionBank = datas.flatMap(d => d.questions || []);
                console.log(`📚 Total questions loaded: ${questionBank.length}`);
                
                // Merge with any saved custom questions from localStorage
                if (window.localStorage) {
                    const saved = localStorage.getItem(QUESTION_BANK_KEY);
                    if (saved) {
                        const savedBank = JSON.parse(saved);
                        // Add only new questions not already in the base question bank
                        const existingIds = questionBank.map(q => q.id);
                        const newQuestions = savedBank.filter(q => !existingIds.includes(q.id));
                        questionBank = [...questionBank, ...newQuestions];
                        console.log(`📂 Added ${newQuestions.length} custom questions from localStorage`);
                    }
                }
                
                console.log(`🎯 Final question bank size: ${questionBank.length}`);
            } catch (error) {
                console.error('❌ Could not load question bank:', error);
                questionBank = [];
            }
        }

        function saveQuestionBank() {
            if (!window.localStorage) return;
            
            try {
                localStorage.setItem(QUESTION_BANK_KEY, JSON.stringify(questionBank));
            } catch (error) {
                console.warn('Could not save question bank:', error);
            }
        }

        function setupDifficultyButtons() {
            difficultyButtons.innerHTML = '';
            
            Object.entries(DIFFICULTY_LEVELS).forEach(([level, info]) => {
                const count = questionBank.filter(q => q.difficulty === level).length;
                const button = document.createElement('button');
                button.className = `btn ${level === currentDifficulty ? 'btn-primary' : 'btn-secondary'}`;
                button.style.cssText = `
                    font-size: 0.8em; 
                    padding: 6px 12px; 
                    margin: 2px;
                    background: ${level === currentDifficulty ? info.color : '#6c757d'};
                `;
                button.innerHTML = `
                    <strong>${level}</strong><br>
                    <small>${info.name} (${count})</small>
                `;
                button.onclick = () => selectDifficulty(level);
                difficultyButtons.appendChild(button);
            });
        }

        function selectDifficulty(level) {
            currentDifficulty = level;
            filterQuestionsByDifficulty();
            setupDifficultyButtons();
            updateDifficultySummary();
            
            // Restart the quiz with new difficulty
            currentQuestion = 0;
            score = 0;
            answered = false;
            userAnswers = [];
            
            loadQuestion();
            updateProgress();
            updateScore();
        }

        function filterQuestionsByDifficulty() {
            questions = questionBank.filter(q => q.difficulty === currentDifficulty);
            
            // Randomize order if there are multiple questions
            if (questions.length > 1) {
                shuffleArray(questions);
            }
        }

        // Shuffle answer options while tracking correct answer position
        function shuffleOptionsWithCorrectAnswer(options, correctIndex) {
            // Create array of option objects with original indices
            const optionsWithIndex = options.map((option, index) => ({
                text: option,
                originalIndex: index
            }));
            
            // Shuffle the array
            shuffleArray(optionsWithIndex);
            
            // Find where the correct answer ended up
            const newCorrectIndex = optionsWithIndex.findIndex(
                option => option.originalIndex === correctIndex
            );
            
            return {
                options: optionsWithIndex.map(option => option.text),
                correctIndex: newCorrectIndex
            };
        }

        function updateDifficultySummary() {
            const levelInfo = DIFFICULTY_LEVELS[currentDifficulty];
            const count = questions.length;
            difficultySummary.textContent = `Current: ${currentDifficulty} ${levelInfo.name} (${count} questions available)`;
        }

        function toggleDifficultyConfig() {
            const isCollapsed = difficultyContent.classList.contains('collapsed');
            
            if (isCollapsed) {
                difficultyContent.classList.remove('collapsed');
                difficultyToggleBtn.classList.remove('collapsed');
                difficultyToggleBtn.textContent = '🔽';
                difficultySummary.classList.remove('show');
            } else {
                difficultyContent.classList.add('collapsed');
                difficultyToggleBtn.classList.add('collapsed');
                difficultyToggleBtn.textContent = '▶️';
                difficultySummary.classList.add('show');
            }
        }

        // Helper function to add new questions (for manual addition via console)
        function addQuestion(questionData) {
            // Validate required fields
            if (!questionData.audioText || !questionData.question || !questionData.options || !questionData.difficulty) {
                console.error('Missing required fields: audioText, question, options, difficulty');
                return false;
            }

            const newQuestion = {
                id: Date.now(),
                audioText: questionData.audioText,
                question: questionData.question,
                questionType: questionData.questionType || 'comprehension',
                options: questionData.options,
                correct: questionData.correct || 0,
                explanation: questionData.explanation || 'No explanation provided',
                difficulty: questionData.difficulty.toUpperCase(),
                source: questionData.source || 'Manual Entry',
                tags: questionData.tags || ['user-content']
            };

            questionBank.push(newQuestion);
            saveQuestionBank();
            setupDifficultyButtons();
            updateDifficultySummary();
            
            console.log('Question added successfully:', newQuestion);
            console.log('Tip: This question is saved to localStorage. To add it permanently to the new question files, tell your AI assistant!');
            return true;
        }

        // Helper function to export current question bank for updating JSON file
        function exportQuestionsForJSON() {
            const questionsOnly = questionBank.map(q => ({
                id: q.id,
                audioText: q.audioText,
                question: q.question,
                questionType: q.questionType || 'comprehension',
                options: q.options,
                correct: q.correct,
                explanation: q.explanation,
                difficulty: q.difficulty,
                source: q.source,
                tags: q.tags
            }));
            
            const jsonOutput = {
                questions: questionsOnly
            };
            
            console.log('Copy this to update your new question files:');
            console.log(JSON.stringify(jsonOutput, null, 4));
            return jsonOutput;
        }

        // Template-based semantic variation system
        function generateVariation(question) {
            // Check if question has template capability
            if (!question.audioTemplate || !question.templateVariables) {
                return question.audioText; // Fallback to static text
            }

            let generatedText = question.audioTemplate;
            const selectedVariables = {};
            
            // Process each template variable
            Object.entries(question.templateVariables).forEach(([varName, varData]) => {
                const { options, weights } = varData;
                
                // Weighted random selection
                const selectedOption = weightedRandomSelect(options, weights);
                selectedVariables[varName] = selectedOption;
                
                // Replace placeholder in template
                const placeholder = `{${varName}}`;
                generatedText = generatedText.replace(placeholder, selectedOption);
            });
            
            // Log the variation for debugging
            console.log(`🎲 Generated variation for Q${question.id}:`, selectedVariables);
            
            return generatedText;
        }

        function weightedRandomSelect(options, weights) {
            // Create cumulative weight array
            const cumulativeWeights = [];
            let sum = 0;
            for (let i = 0; i < weights.length; i++) {
                sum += weights[i];
                cumulativeWeights[i] = sum;
            }
            
            // Generate random number and find corresponding option
            const random = Math.random() * sum;
            for (let i = 0; i < cumulativeWeights.length; i++) {
                if (random <= cumulativeWeights[i]) {
                    return options[i];
                }
            }
            
            // Fallback to first option
            return options[0];
        }

        // Generate template-aware audio text for a question
        function getAudioTextForQuestion(question) {
            // For template-enabled questions, generate a variation
            if (question.audioTemplate && question.templateVariables) {
                const now = Date.now();
                const cacheExpiry = 60 * 60 * 1000; // 60 minutes in milliseconds
                
                // Check if we have a cached variation and if it's still valid
                if (question._generatedVariation && 
                    question._variationTimestamp && 
                    (now - question._variationTimestamp) < cacheExpiry) {
                    return question._generatedVariation;
                }
                
                // Generate new variation and cache it with timestamp
                question._generatedVariation = generateVariation(question);
                question._variationTimestamp = now;
                
                console.log(`⏰ Generated new variation for Q${question.id} (60min cache)`);
                return question._generatedVariation;
            }
            
            // For regular questions, use static text
            return question.audioText;
        }

        // Update options for listening questions with template variations
        function updateListeningOptionsForVariation(question, generatedText) {
            if (question.questionType !== 'listening' || !question.audioTemplate) {
                return; // Only applies to template-enabled listening questions
            }
            
            // Update the first option (correct answer) with the generated text
            if (question.options && question.options.length > 0) {
                question.options[0] = generatedText;
                console.log(`📝 Updated listening options for Q${question.id}`);
            }
        }

        function loadQuestion() {
            if (questions.length === 0) {
                // No questions for this difficulty level
                optionsContainer.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #666;">
                        <h3>No questions available for ${DIFFICULTY_LEVELS[currentDifficulty].name} level</h3>
                        <p>Send some French content to your AI assistant for this level!</p>
                    </div>
                `;
                return;
            }

            const question = questions[currentQuestion];
            answered = false;
            selectedAnswer = null;
            
            // Generate template variation if applicable
            const audioText = getAudioTextForQuestion(question);
            
            // Update listening options if this is a template-enabled listening question
            updateListeningOptionsForVariation(question, audioText);
            
            questionNumberEl.querySelector('span:first-child').textContent = `Question ${currentQuestion + 1} of ${questions.length}`;
            document.getElementById('questionId').textContent = `ID: #${question.id}`;
            // Set question type icon in the left box
            const typeIcon = question.questionType === 'listening' ? '👂' : question.questionType === 'fill-in-the-blank' ? '✏️' : '📖';
            // Find the first tag with an icon in the map
            let tagIcon = '';
            if (question.tags && Array.isArray(question.tags)) {
                for (const tag of question.tags) {
                    if (tagIconMap[tag]) {
                        tagIcon = tagIconMap[tag];
                        break;
                    }
                }
            }
            // Render the icons (type icon + tag icon if present)
            document.getElementById('questionTypeIcon').innerHTML = typeIcon + (tagIcon ? `<span style='font-size:0.7em; margin-left:10px;'>${tagIcon}</span>` : '');
            // Set question text without icon
            questionTextEl.textContent = question.question;
            
            // Randomize answer choices
            const shuffledOptions = shuffleOptionsWithCorrectAnswer(question.options, question.correct);
            
            // Clear and populate options
            optionsContainer.innerHTML = '';
            shuffledOptions.options.forEach((option, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'option';
                optionEl.innerHTML = `
                    <span class="option-letter">${String.fromCharCode(65 + index)}</span>
                    ${option}
                `;
                optionEl.addEventListener('click', () => selectOption(index));
                optionsContainer.appendChild(optionEl);
            });
            
            // Store the new correct answer index after shuffling
            question._shuffledCorrect = shuffledOptions.correctIndex;
            
            // Reset buttons
            submitBtn.disabled = true;
            nextBtn.disabled = true;
            prevBtn.disabled = currentQuestion === 0;
            
            // Hide feedback
            feedback.style.display = 'none';
            
            // Update submit button text
            submitBtn.textContent = currentQuestion === questions.length - 1 ? 'Finish Quiz' : 'Submit Answer';
            
            // Auto-play audio after a short delay (for smooth UX)
            setTimeout(() => {
                playAudio();
            }, 500);
        }

        function selectOption(index) {
            if (answered) return;
            selectedAnswer = index;
            const question = questions[currentQuestion];
            const correctIndex = question._shuffledCorrect !== undefined ? question._shuffledCorrect : question.correct;
            // Update option styling
            document.querySelectorAll('.option').forEach((el, i) => {
                el.classList.remove('selected');
                if (i === index) {
                    el.classList.add('selected');
                }
            });
            if (index === correctIndex) {
                submitAnswer(); // Instantly submit if correct
            } else {
                // Immediately treat as final answer if incorrect
                answered = true;
                userAnswers[currentQuestion] = {
                    selected: selectedAnswer,
                    correct: false
                };
                // Show feedback and highlight correct/incorrect
                showFeedback(question, false);
                document.querySelectorAll('.option').forEach((el, i) => {
                    if (i === correctIndex) {
                        el.classList.add('correct');
                    } else if (i === selectedAnswer) {
                        el.classList.add('incorrect');
                    }
                    // Disable further clicks
                    el.style.pointerEvents = 'none';
                });
                submitBtn.disabled = true;
                nextBtn.disabled = true;
                updateScore();
                // Track vocabulary misses for listening questions on incorrect answer
                if (question.questionType === 'listening') {
                    const correctText = question.options[question.correct].toLowerCase().replace(/[^0-\w\sàâçéèêëîïôûùüÿñæœ-]/g, '');
                    const selectedText = question.options[selectedAnswer].toLowerCase().replace(/[^-\w\sàâçéèêëîïôûùüÿñæœ-]/g, '');
                    const correctWords = new Set(correctText.split(/\s+/));
                    const selectedWords = new Set(selectedText.split(/\s+/));
                    const missedWords = [...correctWords].filter(word => word && !selectedWords.has(word));
                    if (missedWords.length > 0) {
                        console.log('Vocab miss debug | UUID:', userUUID, '| Correct:', correctText, '| Selected:', selectedText, '| Missed:', missedWords);
                        sendCacheMessage({ action: 'track_vocab_miss', words: missedWords, uuid: userUUID })
                            .then(() => console.log('Tracked vocab misses for UUID', userUUID, ':', missedWords))
                            .catch(err => console.warn('Failed to track vocab misses:', err));
                    }
                }
                // Auto-advance after 1.5s
                setTimeout(() => {
                    nextQuestion();
                }, 3000);
            }
        }

        function submitAnswer() {
            if (selectedAnswer === null || answered) return;
            
            answered = true;
            const question = questions[currentQuestion];
            const correctIndex = question._shuffledCorrect !== undefined ? question._shuffledCorrect : question.correct;
            const isCorrect = selectedAnswer === correctIndex;
            
            userAnswers[currentQuestion] = {
                selected: selectedAnswer,
                correct: isCorrect
            };
            
            if (isCorrect) {
                score++;
            }
            
            // Show feedback
            showFeedback(question, isCorrect);
            
            // Update option styling
            document.querySelectorAll('.option').forEach((el, i) => {
                if (i === correctIndex) {
                    el.classList.add('correct');
                } else if (i === selectedAnswer && !isCorrect) {
                    el.classList.add('incorrect');
                }
            });
            
            // Update buttons
            submitBtn.disabled = true;
            nextBtn.disabled = false;
            
            updateScore();
            
            // Auto-advance if correct (after showing feedback briefly)
            if (isCorrect && currentQuestion < questions.length - 1) {
                setTimeout(() => {
                    nextQuestion();
                }, 1500); // Show success feedback for 1.5 seconds before advancing
            }

            // Track vocabulary misses for listening questions on incorrect answer
            if (question.questionType === 'listening' && !isCorrect) {
                const correctText = question.options[question.correct].toLowerCase().replace(/[^0-\w\sàâçéèêëîïôûùüÿñæœ-]/g, '');
                const selectedText = question.options[selectedAnswer].toLowerCase().replace(/[^-\w\sàâçéèêëîïôûùüÿñæœ-]/g, '');
                const correctWords = new Set(correctText.split(/\s+/));
                const selectedWords = new Set(selectedText.split(/\s+/));
                const missedWords = [...correctWords].filter(word => word && !selectedWords.has(word));
                if (missedWords.length > 0) {
                    console.log('Vocab miss debug | UUID:', userUUID, '| Correct:', correctText, '| Selected:', selectedText, '| Missed:', missedWords);
                    sendCacheMessage({ action: 'track_vocab_miss', words: missedWords, uuid: userUUID })
                        .then(() => console.log('Tracked vocab misses for UUID', userUUID, ':', missedWords))
                        .catch(err => console.warn('Failed to track vocab misses:', err));
                }
            }
        }

        function showFeedback(question, isCorrect) {
            feedback.style.display = 'block';
            feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
            feedback.innerHTML = `
                <strong>${isCorrect ? '✅ Correct!' : '❌ Incorrect'}</strong><br>
                ${question.explanation}
            `;
        }

        function nextQuestion() {
            if (currentQuestion < questions.length - 1) {
                currentQuestion++;
                loadQuestion();
                updateProgress();
            } else {
                showFinalResults();
            }
        }

        function prevQuestion() {
            if (currentQuestion > 0) {
                currentQuestion--;
                loadQuestion();
                updateProgress();
            }
        }

        function skipQuestion() {
            // Stop any current audio immediately
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            if (window.speechSynthesis) {
                speechSynthesis.cancel();
            }
            
            // Reset play button state
            playBtn.disabled = false;
            playBtn.innerHTML = '<span>▶️</span> Play Audio';
            
            if (answered) {
                // If already answered, just go to next question
                nextQuestion();
                return;
            }
            
            // Mark as skipped (not correct, not incorrect)
            answered = true;
            userAnswers[currentQuestion] = {
                selected: null,
                correct: false,
                skipped: true
            };
            
            // Show skip feedback
            feedback.style.display = 'block';
            feedback.className = 'feedback';
            feedback.style.background = '#e2e3e5';
            feedback.style.color = '#6c757d';
            feedback.innerHTML = '<strong>⏭️ Question Skipped</strong><br>You can review this later.';
            
            // Update buttons
            submitBtn.disabled = true;
            nextBtn.disabled = false;
            
            updateScore();
            
            // Auto-advance after showing skip message briefly
            setTimeout(() => {
                nextQuestion();
            }, 1000);
        }

        function updateProgress() {
            if (questions.length === 0) {
                progressBar.style.width = '0%';
                return;
            }
            const progress = ((currentQuestion) / questions.length) * 100;
            progressBar.style.width = `${progress}%`;
        }

        function updateScore() {
            if (questions.length === 0) {
                scoreDisplay.textContent = 'Score: 0/0';
                return;
            }
            scoreDisplay.textContent = `Score: ${score}/${currentQuestion + (answered ? 1 : 0)}`;
        }

        function showFinalResults() {
            const skipped = userAnswers.filter(answer => answer && answer.skipped).length;
            const attempted = questions.length - skipped;
            const percentage = attempted > 0 ? Math.round((score / attempted) * 100) : 0;
            
            let message = '';
            if (percentage >= 80) {
                message = '🎉 Excellent work!';
            } else if (percentage >= 60) {
                message = '👍 Good job!';
            } else {
                message = '📚 Keep practicing!';
            }
            
            let resultsHTML = `
                <div style="text-align: center; padding: 20px;">
                    <h2>${message}</h2>
                    <p>You scored ${score} out of ${attempted} attempted (${percentage}%)</p>
            `;
            
            if (skipped > 0) {
                resultsHTML += `<p style="color: #6c757d; margin-top: 10px;">⏭️ ${skipped} question${skipped > 1 ? 's' : ''} skipped</p>`;
            }
            
            resultsHTML += `
                    <button class="btn btn-primary" onclick="restartQuiz()" style="margin-top: 20px;">
                        Try Again
                    </button>
                </div>
            `;
            
            optionsContainer.innerHTML = resultsHTML;
            
            submitBtn.style.display = 'none';
            nextBtn.style.display = 'none';
            skipBtn.style.display = 'none';
        }

        function restartQuiz() {
            currentQuestion = 0;
            selectedAnswer = null;
            score = 0;
            answered = false;
            userAnswers = [];
            
            submitBtn.style.display = 'inline-block';
            skipBtn.style.display = 'inline-block';
            nextBtn.style.display = 'inline-block';
            
            init();
        }

        // Event listeners
        playBtn.addEventListener('click', playAudio);
        submitBtn.addEventListener('click', submitAnswer);
        skipBtn.addEventListener('click', skipQuestion);
        nextBtn.addEventListener('click', nextQuestion);
        prevBtn.addEventListener('click', prevQuestion);

        // AWS config event listeners
        usePollyCheckbox.addEventListener('change', () => {
            pollyConfigDiv.style.display = usePollyCheckbox.checked ? 'block' : 'none';
            initializePolly();
            saveSettings();
        });

        [awsAccessKeyInput, awsSecretKeyInput, awsRegionSelect, pollyVoiceSelect].forEach(el => {
            el.addEventListener('change', () => {
                initializePolly();
                updateConfigSummary();
                saveSettings();
            });
        });

        // Initialize the app
        init();
        initializeCacheUI();

        // --- Tag Icon Map ---
        let tagIconMap = {};
        fetch('tag_icon_map.json')
            .then(r => r.json())
            .then(map => { tagIconMap = map; })
            .catch(() => { tagIconMap = {}; });
    </script>
</body>
</html>