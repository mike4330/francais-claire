<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>French Listening Practice</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- Hamburger Menu -->
        <div class="hamburger-menu" id="hamburgerMenu">
            <button class="hamburger-btn" id="hamburgerBtn" title="Menu" aria-label="Open menu">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </button>
            <div class="menu-dropdown" id="menuDropdown">
                <a href="student.html">üë§ Student Dashboard</a>
                <a href="planning.html">üóÇÔ∏è Planning & Management</a>
                <div class="menu-divider"></div>
                <a href="#" onclick="toggleVoiceSettings(); return false;">üîä Voice Settings</a>
            </div>
        </div>
        
        <div class="header">
            <img src="res/frenchapp.svg" alt="francais claire logo" style="height: 128px; width: 128px; margin-bottom: 10px;">
            <h1>üá´üá∑ Fran√ßais Clair</h1>
            <p>Improve your French listening skills with interactive exercises</p>
        </div>

        <!-- Difficulty Level Selection -->
        <div class="aws-config" style="border-left-color: #667eea;">
            <div class="config-header" onclick="toggleDifficultyConfig()">
                <h3>üìä Difficulty Level</h3>
                <button class="config-toggle-btn" id="difficultyToggleBtn">üîΩ</button>
            </div>
            <div class="config-summary" id="difficultySummary">
                Current: A1 Beginner (3 questions available)
            </div>
            <div class="config-content" id="difficultyContent">
                <div style="margin-bottom: 15px;">
                    <label style="font-weight: 500; color: #333; display: block; margin-bottom: 10px;">
                        Select your target level:
                    </label>
                    <div id="difficultyButtons" style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <!-- Difficulty buttons will be populated by JavaScript -->
                    </div>
                </div>

            </div>
        </div>



        <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <div class="question-container">
            <div class="question-number" id="questionNumber">
                <span>Question 1 of 5</span>
                <div class="question-meta">
                    <span class="question-type-pill" id="questionTypePill">üìñ comprehension</span>
                </div>
            </div>
            <div class="question-text" id="questionText">
                What did you hear?
            </div>
            <div class="audio-controls-container">
                <div class="audio-controls">
                        <button class="play-btn" id="playBtn" title="Play Audio">
                            <span>‚ñ∂Ô∏è</span>
                        </button>
                        <div class="speed-control" title="Playback Speed">
                            <span>üéöÔ∏è</span>
                            <select id="speedSelect">
                                <option value="0.75">0.75x</option>
                                <option value="0.9" selected>0.9x</option>
                                <option value="1">1x</option>
                                <option value="1.1">1.1x</option>
                                <option value="1.25">1.25x</option>
                            </select>
                        </div>
                </div>
            </div>
            <div class="options" id="optionsContainer">
                <!-- Options will be populated by JavaScript -->
            </div>
            <div class="feedback" id="feedback" style="display: none;"></div>
        </div>

        <div class="controls">
            <button class="btn btn-secondary" id="prevBtn" disabled title="Go to previous question">‚¨ÖÔ∏è</button>
            <button class="btn btn-secondary" id="skipBtn" title="Skip this question">‚è≠Ô∏è</button>
            <button class="btn btn-primary" id="submitBtn" disabled title="Submit your answer">‚úÖ</button>
        </div>

        <div class="score" id="scoreDisplay">Score: 0/0</div>
    </div>

    <!-- Explanation Modal -->
    <div class="modal-overlay" id="explanationModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Question Result</h3>
                <button class="modal-close" id="modalCloseBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div id="modalFeedback" class="modal-feedback"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="modalNextBtn">Next Question</button>
            </div>
        </div>
    </div>

    <!-- Voice Settings Modal -->
    <div class="modal-overlay" id="voiceSettingsModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üîä Voice Settings</h3>
                <button class="modal-close" id="voiceModalCloseBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="config-toggle">
                    <input type="checkbox" id="usePolly" checked>
                    <label for="usePolly">Use Neural TTS (uncheck for browser TTS fallback)</label>
                </div>
                <div id="pollyConfig">
                    <div class="config-row">
                        <label>Voice:</label>
                        <select id="pollyVoice">
                            <option value="Lea">L√©a (Female, French - Neural)</option>
                            <option value="Remi">R√©mi (Male, French - Neural)</option>
                        </select>
                    </div>
                    <div class="config-status" id="configStatus">
                        ‚úÖ Neural TTS ready
                    </div>
                    <div style="margin-top: 15px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                            <button class="btn btn-secondary" onclick="clearSettings()" style="font-size: 0.9em; padding: 8px 15px;">
                                üóëÔ∏è Clear Settings
                            </button>
                            <button class="btn btn-secondary" onclick="preCacheAllQuestions()" style="font-size: 0.9em; padding: 8px 15px;">
                                üîÑ Pre-Cache All
                            </button>
                            <button class="btn btn-secondary" onclick="clearRedisCache()" style="font-size: 0.9em; padding: 8px 15px;">
                                üóëÔ∏è Clear Redis Cache
                            </button>
                            <button class="btn btn-secondary" onclick="regenerateVariations()" style="font-size: 0.9em; padding: 8px 15px;">
                                üé≤ New Variations
                            </button>
                            <button class="btn btn-secondary" id="cacheStatsBtn" style="font-size: 0.9em; padding: 8px 15px; cursor: default;" disabled>
                                üìä Redis: Connecting...
                            </button>
                        </div>
                        <div id="cacheStatus" class="config-status not-ready" style="margin-bottom: 10px;">
                            Connecting to Redis cache server...
                        </div>
                        <small style="color: #666;">Audio cached in Redis via WebSocket ‚Ä¢ Automatic caching enabled ‚Ä¢ Settings auto-saved</small>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeVoiceSettings()">Close</button>
            </div>
        </div>
    </div>

    <!-- External scripts -->
    <script src="function.js"></script>

    <script>
        // --- User UUID Cookie Logic ---
        // Utility functions now in function.js: getCookie, setCookie, generateUUIDv4
        // Set UUID cookie if not present
        let userUUID = getCookie('french_listening_uuid');
        if (!userUUID) {
            userUUID = generateUUIDv4();
            setCookie('french_listening_uuid', userUUID, 730); // 2 years
        }
        // --- End User UUID Cookie Logic ---

        // French News Listening Training System
        // Difficulty levels: A1 (basic) -> C2 (advanced news)
        const DIFFICULTY_LEVELS = {
            'A1': { name: 'Beginner', color: '#28a745', description: 'Simple phrases, basic vocabulary' },
            'A2': { name: 'Elementary', color: '#20c997', description: 'Everyday expressions, personal topics' },
            'B1': { name: 'Intermediate', color: '#fd7e14', description: 'Work, travel, familiar topics' },
            'B2': { name: 'Upper-Intermediate', color: '#e83e8c', description: 'Abstract topics, complex ideas' },
            'C1': { name: 'Advanced', color: '#6f42c1', description: 'Professional, academic content' },
            'C2': { name: 'C2 - Proficiency', color: '#dc3545', description: 'French news, media, complex discourse' }
        };

        // Question bank loaded from external JSON file
        let questionBank = [];
        
        // Sublevel mapping for precise question selection
        let sublevelMapping = {};

        let currentDifficulty = 'A1';

        // App state - current question now loaded directly by ID
        let currentQuestionData = null;
        let selectedAnswer = null;
        let score = 0;
        let answered = false;
        let userAnswers = [];
        let questionStartTime = null;
        
        // Session history for Previous button functionality
        let questionHistory = [];

        // TTS configuration
        let currentAudio = null;

        // Settings persistence
        const SETTINGS_KEY = 'french-listening-polly-settings';
        const QUESTION_BANK_KEY = 'french-listening-question-bank';

        // DOM elements
        const questionNumberEl = document.getElementById('questionNumber');
        const questionTextEl = document.getElementById('questionText');
        const optionsContainer = document.getElementById('optionsContainer');
        const playBtn = document.getElementById('playBtn');
        const speedSelect = document.getElementById('speedSelect');
        const submitBtn = document.getElementById('submitBtn');
        const skipBtn = document.getElementById('skipBtn');
        const prevBtn = document.getElementById('prevBtn');
        const progressBar = document.getElementById('progressBar');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const feedback = document.getElementById('feedback');

        // Modal elements
        const explanationModal = document.getElementById('explanationModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalFeedback = document.getElementById('modalFeedback');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalNextBtn = document.getElementById('modalNextBtn');

        // TTS Config elements
        const usePollyCheckbox = document.getElementById('usePolly');
        const pollyConfigDiv = document.getElementById('pollyConfig');
        const pollyVoiceSelect = document.getElementById('pollyVoice');
        const configStatusEl = document.getElementById('configStatus');

        // Difficulty system elements
        const difficultyToggleBtn = document.getElementById('difficultyToggleBtn');
        const difficultyContent = document.getElementById('difficultyContent');
        const difficultySummary = document.getElementById('difficultySummary');
        const difficultyButtons = document.getElementById('difficultyButtons');

        // Scoring stats elements
        const scoringToggleBtn = document.getElementById('scoringToggleBtn');
        const scoringContent = document.getElementById('scoringContent');
        const scoringSummary = document.getElementById('scoringSummary');
        const scoringStatsContainer = document.getElementById('scoringStatsContainer');

        // Hamburger menu toggle logic
        const hamburgerBtn = document.getElementById('hamburgerBtn');
        const menuDropdown = document.getElementById('menuDropdown');
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        hamburgerBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            hamburgerMenu.classList.toggle('open');
        });
        document.addEventListener('click', function(e) {
            if (!hamburgerMenu.contains(e.target)) {
                hamburgerMenu.classList.remove('open');
            }
        });

        // Helper function to set play button text based on screen size
        function setPlayButtonState(isPlaying = false) {
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                playBtn.innerHTML = isPlaying ? '<span>üîä</span>' : '<span>‚ñ∂Ô∏è</span>';
            } else {
                playBtn.innerHTML = isPlaying ? '<span>üîä</span> Playing...' : '<span>‚ñ∂Ô∏è</span> Play Audio';
            }
        }

        // Update button text on window resize
        window.addEventListener('resize', () => {
            const isCurrentlyPlaying = playBtn.innerHTML.includes('üîä');
            setPlayButtonState(isCurrentlyPlaying);
        });

        // TTS Setup
        function initializePolly() {
            if (!usePollyCheckbox.checked) {
                updateConfigStatus('Browser TTS mode', 'ready');
                return true;
            }

            updateConfigStatus('‚úÖ Neural TTS ready', 'ready');
            return true;
        }

        function updateConfigStatus(message, status) {
            configStatusEl.textContent = message;
            configStatusEl.className = `config-status ${status}`;
            updateConfigSummary();
        }

        function updateConfigSummary() {
            // Summary is now in the modal - no need to update main page
        }

        // Settings persistence functions
        function saveSettings() {
            if (!window.localStorage) return;
            
            const settings = {
                usePolly: usePollyCheckbox.checked,
                voice: pollyVoiceSelect.value
            };
            
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
            } catch (error) {
                console.warn('Could not save settings to localStorage:', error);
            }
        }

        function loadSettings() {
            if (!window.localStorage) return;
            
            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (!saved) return;
                
                const settings = JSON.parse(saved);
                
                // Restore form values
                if (settings.usePolly !== undefined) usePollyCheckbox.checked = settings.usePolly;
                if (settings.voice) pollyVoiceSelect.value = settings.voice;
                
                
                // Re-initialize Polly with loaded settings
                initializePolly();
                
            } catch (error) {
                console.warn('Could not load settings from localStorage:', error);
            }
        }

        function clearSettings() {
            if (!window.localStorage) return;
            
            try {
                localStorage.removeItem(SETTINGS_KEY);
                
                // Reset form to defaults
                usePollyCheckbox.checked = true;
                pollyVoiceSelect.value = 'Lea';
                
                
                // Re-initialize
                initializePolly();
                
                alert('Settings cleared successfully!');
            } catch (error) {
                console.warn('Could not clear settings:', error);
            }
        }

        // Redis cache management functions
        async function updateCacheStats() {
            try {
                const result = await sendCacheMessage({ action: 'get_stats' });
                const btn = document.getElementById('cacheStatsBtn');
                if (btn) {
                    btn.textContent = `üìä Redis: ${result.count} files (${result.sizeMB}MB)`;
                }
            } catch (error) {
                console.warn('‚ùå Failed to get cache stats:', error.message);
            }
        }

        async function clearRedisCache() {
            if (!confirm('Clear all cached audio files from Redis? This will require re-downloading from Polly.')) {
                return;
            }
            
            try {
                const result = await sendCacheMessage({ action: 'clear_cache' });
                alert(`Cleared ${result.cleared} cached audio files from Redis.`);
                updateCacheStats();
            } catch (error) {
                console.error('‚ùå Failed to clear cache:', error.message);
                alert('Failed to clear cache. Check console for details.');
            }
        }

        // Surgically evict a specific question from cache
        async function evictQuestionFromCache(questionId) {
            const question = questionBank.find(q => q.id === questionId);
            if (!question) {
                console.error(`‚ùå Question ${questionId} not found`);
                return false;
            }

            const voiceId = pollyVoiceSelect.value;
            
            try {
                const result = await sendCacheMessage({ 
                    action: 'evict_cache',
                    text: question.audioText,
                    voiceId: voiceId
                });
                
                if (result.evicted) {
                    console.log(`‚úÖ Question ${questionId} evicted from cache`);
                    updateCacheStats();
                    return true;
                } else {
                    console.log(`‚ÑπÔ∏è Question ${questionId} was not in cache`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Failed to evict question ${questionId}:`, error.message);
                return false;
            }
        }

        // Convenience function to evict question 9 specifically
        async function evictQuestion9() {
            const result = await evictQuestionFromCache(9);
            if (result) {
                alert('Question 9 has been surgically evicted from cache! Next play will use fresh SSML synthesis.');
            } else {
                alert('Question 9 was not found in cache (or eviction failed).');
            }
        }

        // Regenerate template variations for all questions
        function regenerateVariations() {
            let regeneratedCount = 0;
            
            // Clear existing generated variations and timestamps
            questionBank.forEach(question => {
                if (question.audioTemplate && question.templateVariables) {
                    delete question._generatedVariation;
                    delete question._variationTimestamp;
                    regeneratedCount++;
                }
            });
            
            // If we're currently viewing a template-enabled question, reload it
            if (questions.length > 0 && currentQuestion < questions.length) {
                const currentQ = questions[currentQuestion];
                if (currentQ.audioTemplate && currentQ.templateVariables) {
                    loadQuestion();
                }
            }
            
            if (regeneratedCount > 0) {
                console.log(`üé≤ Regenerated variations for ${regeneratedCount} template-enabled questions`);
                alert(`Generated new variations for ${regeneratedCount} questions! Play audio to hear the changes.`);
            } else {
                alert('No template-enabled questions found in current question bank.');
            }
        }

        async function preCacheAllQuestions() {
            if (!usePollyCheckbox.checked) {
                alert('Please enable Neural TTS first!');
                return;
            }

            if (!cacheSocket || cacheSocket.readyState !== WebSocket.OPEN) {
                alert('Redis cache server not connected!');
                return;
            }

            const btn = event.target;
            const originalText = btn.textContent;
            
            try {
                btn.disabled = true;
                btn.textContent = 'üîÑ Caching...';
                
                const voiceId = pollyVoiceSelect.value;
                let cached = 0;
                let total = questionBank.length;
                
                for (let i = 0; i < questionBank.length; i++) {
                    const question = questionBank[i];
                    
                    // Check if already cached in Redis
                    const existing = await getCachedAudio(question.audioText, voiceId);
                    if (existing) {
                        console.log(`‚úÖ Already cached: ${question.audioText.substring(0, 30)}...`);
                        continue;
                    }
                    
                    // Generate and cache
                    btn.textContent = `üîÑ Caching ${i + 1}/${total}...`;
                    
                    try {
                        await synthesizeWithPolly(question.audioText);
                        cached++;
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 500));
                    } catch (error) {
                        console.error(`‚ùå Failed to cache question ${question.id}:`, error);
                    }
                }
                
                updateCacheStats();
                alert(`Pre-caching complete! ${cached} new audio files stored in Redis.`);
                
            } catch (error) {
                console.error('‚ùå Pre-cache error:', error);
                alert('Pre-caching failed. Check console for details.');
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // Initialize cache UI on load
        function initializeCacheUI() {
            initializeCacheSocket();
            // Initial stats update after connection
            setTimeout(updateCacheStats, 2000);
        }


        // WebSocket Redis Cache Integration
        let cacheSocket = null;
        let cachePromises = new Map(); // Track pending cache operations

        // Initialize WebSocket connection to Redis cache server
        function initializeCacheSocket() {
            try {
                cacheSocket = new WebSocket('ws://localhost:8080');
                
                cacheSocket.onopen = () => {
                    console.log('‚úÖ Connected to Redis cache server');
                    updateCacheStatus('Connected to Redis cache', 'ready');
                };
                
                cacheSocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    // Create a truncated version for logging (omit large audioData)
                    const logData = { ...data };
                    if (logData.audioData) {
                        logData.audioData = `[${logData.audioData.length} bytes]`;
                    }
                    console.log('üì® Received cache message:', logData);
                    handleCacheMessage(data);
                };
                
                cacheSocket.onclose = () => {
                    console.log('‚ùå Disconnected from Redis cache server');
                    updateCacheStatus('Redis cache disconnected', 'not-ready');
                    // Attempt reconnection after 5 seconds
                    setTimeout(initializeCacheSocket, 5000);
                };
                
                cacheSocket.onerror = (error) => {
                    console.error('‚ùå Cache WebSocket error:', error);
                    updateCacheStatus('Redis cache error', 'not-ready');
                };
            } catch (error) {
                console.error('‚ùå Failed to connect to cache server:', error);
                updateCacheStatus('Cache server unavailable', 'not-ready');
            }
        }

        function updateCacheStatus(message, status) {
            // Update UI to show cache status
            const statusEl = document.getElementById('cacheStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `config-status ${status}`;
            }
        }

        function handleCacheMessage(data) {
            const { type } = data;
            
            // Find matching promise by comparing the original message
            let matchingKey = null;
            
            for (const [key, promiseData] of cachePromises.entries()) {
                const { message } = promiseData;
                
                if ((type === 'cache_check_result' && message.action === 'check_cache') ||
                    (type === 'cache_store_result' && message.action === 'store_cache') ||
                    (type === 'stats_result' && message.action === 'get_stats') ||
                    (type === 'clear_cache_result' && message.action === 'clear_cache') ||
                    (type === 'evict_cache_result' && message.action === 'evict_cache') ||
                    (type === 'scoring_stats_result' && message.action === 'get_scoring_stats') ||
                    (type === 'question_result_tracked' && message.action === 'track_question_result') ||
                    (type === 'detailed_response_tracked' && message.action === 'track_detailed_question_response') ||
                    (type === 'scoring_stats_cleared' && message.action === 'clear_scoring_stats') ||
                    (type === 'user_question_performance_result' && message.action === 'get_user_question_performance')) {
                    matchingKey = key;
                    break;
                }
            }
            
            if (matchingKey) {
                const { message, resolve } = cachePromises.get(matchingKey);
                
                // Special handling for user performance data
                if (type === 'user_question_performance_result' && message.action === 'get_user_question_performance') {
                    userPerformanceData = data.questionPerformances || [];
                    debugLog(2, `üìä Loaded ${userPerformanceData.length} user performance records for intelligent selection`);
                    
                    // If we have a pending level start, trigger it now that data is loaded
                    if (window.pendingLevelStart) {
                        const level = window.pendingLevelStart;
                        window.pendingLevelStart = null;
                        debugLog(2, `üöÄ Triggering delayed level start for ${level} now that performance data is loaded`);
                        startWithLevelAfterDataLoad(level);
                    }
                }
                
                resolve(data);
                cachePromises.delete(matchingKey);
            } else {
                console.log('‚ö†Ô∏è No matching promise found for:', type);
            }
        }

        function sendCacheMessage(message) {
            return new Promise((resolve, reject) => {
                if (!cacheSocket || cacheSocket.readyState !== WebSocket.OPEN) {
                    reject(new Error('Cache server not connected'));
                    return;
                }
                
                // Create a unique key using text and voice for cache operations
                let promiseKey;
                if (message.text && message.voiceId) {
                    promiseKey = `${message.action}_${message.text}_${message.voiceId}`;
                } else {
                    promiseKey = `${message.action}_${Date.now()}`;
                }
                
                cachePromises.set(promiseKey, { resolve, reject, message });
                
                debugLog(5, 'üì§ Sending cache message:', message);
                cacheSocket.send(JSON.stringify(message));
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    if (cachePromises.has(promiseKey)) {
                        cachePromises.delete(promiseKey);
                        reject(new Error('Cache operation timeout'));
                    }
                }, 10000);
            });
        }

        // Check if cached audio exists in Redis
        async function getCachedAudio(text, voiceId, speed = 1.0) {
            try {
                const result = await sendCacheMessage({
                    action: 'check_cache',
                    text: text,
                    voiceId: voiceId
                });
                
                if (result.exists && result.audioData) {
                    // Convert base64 back to audio blob
                    const binaryString = atob(result.audioData);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const audioBlob = new Blob([bytes], { type: 'audio/mpeg' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    audio.playbackRate = speed;
                    return audio;
                }
                return null;
            } catch (error) {
                console.log('‚ùå Cache check failed:', error.message);
                return null;
            }
        }

        // Save audio to Redis cache
        async function saveToCache(audioBlob, text, voiceId) {
            try {
                // Convert blob to base64
                const arrayBuffer = await audioBlob.arrayBuffer();
                const byteArray = new Uint8Array(arrayBuffer);
                let binaryString = '';
                for (let i = 0; i < byteArray.length; i++) {
                    binaryString += String.fromCharCode(byteArray[i]);
                }
                const base64Data = btoa(binaryString);
                
                await sendCacheMessage({
                    action: 'store_cache',
                    text: text,
                    voiceId: voiceId,
                    audioData: base64Data
                });
                
                console.log(`üíæ Cached audio in Redis: ${text.substring(0, 30)}...`);
                updateCacheStats();
            } catch (error) {
                console.warn('‚ùå Failed to cache audio:', error.message);
            }
        }

        // Audio synthesis with TTS proxy and Redis caching
        async function synthesizeWithPolly(text, speed = 1.0, ssml = null) {
            const voiceId = pollyVoiceSelect.value;
            
            // Use SSML if provided, otherwise use plain text
            const audioContent = ssml || text;
            
            if (ssml) {
                console.log('üé§ SSML detected - using enhanced speech synthesis');
            }
            
            // Try to get from Redis cache first (use original text for cache key)
            const cachedAudio = await getCachedAudio(text, voiceId, speed);
            if (cachedAudio) {
                console.log(`‚úÖ Using cached audio for: ${text.substring(0, 30)}...`);
                return cachedAudio;
            }

            // Cache miss - synthesize with TTS proxy
            debugLog(4, `üîä Synthesizing with TTS proxy: ${text.substring(0, 30)}...`);

            try {
                const response = await fetch('tts-proxy.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: audioContent,
                        voiceId: voiceId,
                        engine: 'neural'
                    })
                });

                if (!response.ok) {
                    throw new Error(`TTS proxy error: ${response.status}`);
                }

                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'TTS synthesis failed');
                }

                // Convert base64 to blob
                const audioBlob = new Blob([
                    Uint8Array.from(atob(data.audio), c => c.charCodeAt(0))
                ], { type: 'audio/mpeg' });
                
                // Save to Redis cache (use original text for cache key)
                await saveToCache(audioBlob, text, voiceId);
                
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                audio.playbackRate = speed;
                
                return audio;
            } catch (error) {
                console.error('‚ùå TTS synthesis error:', error);
                throw error;
            }
        }

        // Fallback to browser TTS
        function synthesizeWithBrowser(text, speed = 1.0) {
            return new Promise((resolve, reject) => {
                if (!window.speechSynthesis) {
                    reject(new Error('Browser TTS not supported'));
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'fr-FR';
                utterance.rate = speed;

                utterance.onend = () => resolve();
                utterance.onerror = (error) => reject(error);

                speechSynthesis.speak(utterance);
            });
        }

        // Play audio function
        async function playAudio() {
            const question = currentQuestionData;
            if (!question) {
                console.error('No current question data available for audio playback');
                return;
            }
            const speed = parseFloat(speedSelect.value);
            
            // Get the appropriate audio text (template variation or static)
            const audioText = getAudioTextForQuestion(question);
            
            // Stop any current audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            if (window.speechSynthesis) {
                speechSynthesis.cancel();
            }
            
            // Update button state
            playBtn.disabled = true;
            setPlayButtonState(true);
            
            try {
                if (usePollyCheckbox.checked) {
                    // Use Neural TTS with SSML support (using generated audio text)
                    currentAudio = await synthesizeWithPolly(audioText, speed, question.ssml);
                    
                    currentAudio.onended = () => {
                        playBtn.disabled = false;
                        setPlayButtonState(false);
                        currentAudio = null;
                    };
                    
                    currentAudio.onerror = () => {
                        playBtn.disabled = false;
                        setPlayButtonState(false);
                        alert('Audio playback error occurred.');
                    };
                    
                    await currentAudio.play();
                } else {
                    // Fallback to browser TTS (uses generated text)
                    await synthesizeWithBrowser(audioText, speed);
                    playBtn.disabled = false;
                    setPlayButtonState(false);
                }
            } catch (error) {
                console.error('Audio playback error:', error);
                playBtn.disabled = false;
                setPlayButtonState(false);
                alert(`Audio playback failed: ${error.message}`);
            }
        }

        // Global configuration object
        let appConfig = {
            debugLevel: 2, // Default fallback value
            interQuestionDelays: {
                correct: 1500,
                incorrect: 2500,
                skipped: 1000
            }
        };

        // Load application configuration
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                if (response.ok) {
                    const config = await response.json();
                    appConfig = { ...appConfig, ...config }; // Merge with defaults
                    console.log(`üîß Config loaded: debugLevel=${appConfig.debugLevel}, delays=[${appConfig.interQuestionDelays.correct}/${appConfig.interQuestionDelays.incorrect}/${appConfig.interQuestionDelays.skipped}]ms`);
                } else {
                    console.warn(`‚ö†Ô∏è Could not load config.json (${response.status}), using defaults`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Config loading failed, using defaults:', error.message);
            }
        }

        // Debug logging utility that respects debugLevel config
        function debugLog(level, message, ...args) {
            if (appConfig.debugLevel >= level) {
                const levelNames = { 0: 'SILENT', 1: 'ERROR', 2: 'WARN', 3: 'INFO', 4: 'DEBUG', 5: 'VERBOSE' };
                const levelName = levelNames[level] || 'UNKNOWN';
                console.log(`[${levelName}] ${message}`, ...args);
            }
        }

        // Background Image Rotator
        async function initializeImageRotator() {
            // Check if image rotator is enabled in config
            const rotatorConfig = appConfig.imageRotator || {
                intervalMinutes: 2,
                directory: 'res/photos/',
                enabled: true
            };
            
            if (!rotatorConfig.enabled) {
                debugLog(2, 'üé® Image rotator disabled in config');
                return;
            }
            
            // Dynamically discover available images
            const discoveredImages = await discoverImages(rotatorConfig.directory);
            
            if (discoveredImages.length === 0) {
                debugLog(1, '‚ùå No background images found in', rotatorConfig.directory);
                return;
            }
            
            // Randomize the order of images
            const images = [...discoveredImages];
            shuffleArray(images);
            debugLog(3, `üîÄ Randomized image order:`, images);
            
            let currentImageIndex = 0;
            
            // Function to change background image
            function rotateBackground() {
                const questionContainer = document.querySelector('.question-container');
                if (questionContainer) {
                    questionContainer.style.setProperty('--bg-image', `url('${images[currentImageIndex]}')`);
                    debugLog(3, `üñºÔ∏è Background rotated to: ${images[currentImageIndex]}`);
                    
                    // Move to next image
                    currentImageIndex = (currentImageIndex + 1) % images.length;
                }
            }
            
            // Set initial image
            rotateBackground();
            
            // Calculate interval from config (convert minutes to milliseconds)
            const intervalMs = rotatorConfig.intervalMinutes * 60 * 1000;
            
            // Rotate at configured interval
            setInterval(rotateBackground, intervalMs);
            
            debugLog(2, `üé® Image rotator initialized with ${images.length} images, rotating every ${rotatorConfig.intervalMinutes} minutes`);
        }
        
        // Discover available images by testing if they exist
        async function discoverImages(directory) {
            const images = [];
            const maxImages = 50; // Safety limit to prevent infinite loop
            
            // Test single digit numbers (1.jpg, 2.jpg, etc.)
            for (let i = 1; i <= 9; i++) {
                const imagePath = `${directory}${i}.jpg`;
                if (await imageExists(imagePath)) {
                    images.push(imagePath);
                    debugLog(4, `‚úÖ Found image: ${imagePath}`);
                } else {
                    debugLog(4, `‚ùå Image not found: ${imagePath}`);
                }
            }
            
            // Test double digit numbers (10.jpg, 11.jpg, etc.)
            for (let i = 10; i <= maxImages; i++) {
                const imagePath = `${directory}${i}.jpg`;
                if (await imageExists(imagePath)) {
                    images.push(imagePath);
                    debugLog(4, `‚úÖ Found image: ${imagePath}`);
                } else {
                    // Stop looking if we hit 3 consecutive missing images
                    break;
                }
            }
            
            debugLog(3, `üîç Discovered ${images.length} background images:`, images);
            return images;
        }
        
        // Check if an image exists by trying to load it
        function imageExists(src) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                img.src = src;
                
                // Timeout after 2 seconds
                setTimeout(() => resolve(false), 2000);
            });
        }

        // Initialize app
        async function init() {
            await loadConfig(); // Load configuration first
            await loadQuestionBankMulti(); // Load questions from multiple JSON files
            await loadSublevelDictionary(); // Load sublevel mapping for precise question selection
            setupDifficultyButtons();
            loadSettings(); // Load saved settings first
            
            // Initialize background image rotator
            await initializeImageRotator();
            
            // Load user performance data for intelligent question selection
            // Wait a bit for cache socket to be ready, then load performance data
            setTimeout(() => {
                loadUserPerformanceData();
            }, 1000);
            
            // Check for URL parameter to start with a specific question
            const urlParams = new URLSearchParams(window.location.search);
            const startQuestionId = urlParams.get('start');
            
            if (startQuestionId) {
                startWithSpecificQuestion(parseInt(startQuestionId));
            } else {
                loadQuestion();
            }
            
            updateProgress();
            updateScore();
            // initializePolly() is called by loadSettings()
        }

        // Question bank management
        async function loadQuestionBankMulti(files = null, useCompiled = true) {
            try {
                // Use centralized loading function with compiled files by default
                const options = {
                    useCompiled: useCompiled,
                    enableLogging: appConfig.debugLevel >= 3,
                    logLevel: appConfig.debugLevel
                };
                
                // Only include files parameter if it's not null (to use defaults)
                if (files !== null) {
                    options.files = files;
                }
                
                const result = await loadQuestionBank(options);
                
                if (result.success) {
                    questionBank = result.questions;
                    debugLog(2, `üìö Loaded ${result.totalCount} questions from ${result.compiledMode ? 'compiled' : 'original'} files`);
                    if (result.compiledMode) {
                        debugLog(3, '‚ú® Using compiled question files for optimal performance');
                    }
                } else {
                    debugLog(1, '‚ùå Question loading failed:', result.error);
                    questionBank = [];
                }
                
                // Merge with any saved custom questions from localStorage
                if (window.localStorage) {
                    const saved = localStorage.getItem(QUESTION_BANK_KEY);
                    if (saved) {
                        const savedBank = JSON.parse(saved);
                        // Add only new questions not already in the base question bank
                        const existingIds = questionBank.map(q => q.id);
                        const newQuestions = savedBank.filter(q => !existingIds.includes(q.id));
                        questionBank = [...questionBank, ...newQuestions];
                        debugLog(4, `üìÇ Added ${newQuestions.length} custom questions from localStorage`);
                    }
                }
                
                debugLog(3, `üéØ Final question bank size: ${questionBank.length}`);
            } catch (error) {
                debugLog(1, '‚ùå Could not load question bank:', error);
                questionBank = [];
            }
        }

        // Load sublevel dictionary for precise question selection
        async function loadSublevelDictionary() {
            try {
                const response = await fetch('questions/sublevel-dictionary.json');
                if (response.ok) {
                    const data = await response.json();
                    sublevelMapping = data.sublevelMapping || {};
                    debugLog(2, `üìä Loaded sublevel mappings for: ${Object.keys(sublevelMapping).join(', ')}`);
                    
                    // Log distribution for debugging
                    if (appConfig.debugLevel >= 3) {
                        Object.entries(sublevelMapping).forEach(([level, questions]) => {
                            debugLog(3, `   ${level}: ${questions.length} questions`);
                        });
                    }
                } else {
                    debugLog(1, '‚ùå Could not load sublevel dictionary:', response.status);
                }
            } catch (error) {
                debugLog(1, '‚ùå Error loading sublevel dictionary:', error);
                sublevelMapping = {};
            }
        }

        function saveQuestionBank() {
            if (!window.localStorage) return;
            
            try {
                localStorage.setItem(QUESTION_BANK_KEY, JSON.stringify(questionBank));
            } catch (error) {
                console.warn('Could not save question bank:', error);
            }
        }

        function setupDifficultyButtons() {
            difficultyButtons.innerHTML = '';
            
            Object.entries(DIFFICULTY_LEVELS).forEach(([level, info]) => {
                const count = questionBank.filter(q => q.difficulty === level).length;
                const button = document.createElement('button');
                button.className = `btn ${level === currentDifficulty ? 'btn-primary' : 'btn-secondary'}`;
                button.style.cssText = `
                    font-size: 0.8em; 
                    padding: 6px 12px; 
                    margin: 2px;
                    background: ${level === currentDifficulty ? info.color : '#6c757d'};
                `;
                button.innerHTML = `
                    <strong>${level}</strong><br>
                    <small>${info.name} (${count})</small>
                `;
                button.onclick = () => selectDifficulty(level);
                difficultyButtons.appendChild(button);
            });
        }

        function selectDifficulty(level) {
            currentDifficulty = level;
            setupDifficultyButtons();
            updateDifficultySummary();
            
            // Restart the quiz with new difficulty
            currentQuestion = 0;
            score = 0;
            answered = false;
            userAnswers = [];
            questionHistory = []; // Clear session history
            
            // Load performance data first, then use intelligent question selection
            loadUserPerformanceDataThenStart(level);
            
            updateProgress();
            updateScore();
        }
        
        // Load performance data and then start with intelligent question selection
        function loadUserPerformanceDataThenStart(level) {
            // Debug WebSocket and UUID status
            debugLog(2, `üîç Checking performance data prerequisites for level ${level}:`);
            debugLog(2, `   üì° WebSocket exists: ${!!cacheSocket}`);
            debugLog(2, `   üì° WebSocket ready: ${cacheSocket ? cacheSocket.readyState === WebSocket.OPEN : 'N/A'}`);
            debugLog(2, `   üë§ User UUID: ${userUUID ? 'Set' : 'Missing'}`);
            
            if (cacheSocket && cacheSocket.readyState === WebSocket.OPEN && userUUID) {
                debugLog(2, `üìä Loading user performance data for level ${level} selection...`);
                
                // Store a callback to execute after performance data loads
                window.pendingLevelStart = level;
                
                sendCacheMessage({ action: 'get_user_question_performance', uuid: userUUID });
            } else {
                debugLog(2, `‚ö†Ô∏è Cannot load performance data: WebSocket not ready or no user UUID, using fallback`);
                debugLog(2, `üîÑ Attempting to retry in 1 second...`);
                
                // Try to wait a bit for WebSocket to be ready
                setTimeout(() => {
                    if (cacheSocket && cacheSocket.readyState === WebSocket.OPEN && userUUID) {
                        debugLog(2, `‚úÖ Retry successful! Loading performance data for level ${level}`);
                        window.pendingLevelStart = level;
                        sendCacheMessage({ action: 'get_user_question_performance', uuid: userUUID });
                    } else {
                        debugLog(2, `‚ö†Ô∏è Retry failed. Proceeding with fallback (no performance data)`);
                        userPerformanceData = [];
                        startWithLevelAfterDataLoad(level);
                    }
                }, 1000);
            }
        }
        
        // Start the quiz after performance data is loaded
        function startWithLevelAfterDataLoad(level) {
            // Reset recently answered questions when starting a new level
            window.recentlyAnsweredQuestions = [];
            
            const bestQuestionId = findBestQuestionForLevel(level);
            if (bestQuestionId) {
                debugLog(2, `üéØ Intelligent selection chose question ${bestQuestionId} for level ${level}`);
                startWithSpecificQuestion(bestQuestionId);
            } else {
                // No intelligent selection possible for this level
                debugLog(2, `‚ö†Ô∏è No questions available for level ${level}`);
                loadQuestion(); // Will show empty state
            }
        }

        // Removed filterQuestionsByDifficulty() - now using direct intelligent selection

        // Global variable to store user performance data for intelligent selection
        let userPerformanceData = [];

        // Find the best question to start with for a given difficulty level using timestamp-based exclusion
        function findBestQuestionForLevel(level) {
            let questionsInLevel = questionBank.filter(q => q.difficulty === level);
            
            // Apply timestamp-based exclusion to avoid recently answered questions
            const recentThresholdMs = (appConfig.intelligentSelection?.recentAnswerThresholdMinutes || 10) * 60 * 1000;
            const now = Date.now();
            
            // Priority 0: Check for questions that are 75% through threshold AND have poor success rate
            // These bypass the normal timestamp filtering for targeted practice
            const priority0Questions = questionsInLevel.filter(question => {
                const performance = userPerformanceData.find(p => p.questionId === question.id);
                
                if (!performance || !performance.lastAnswered) return false;
                
                const timeSinceAnswered = now - performance.lastAnswered;
                const thresholdPercent = (timeSinceAnswered / recentThresholdMs) * 100;
                
                return thresholdPercent >= 75 && timeSinceAnswered < recentThresholdMs && performance.successRate < 70;
            }).sort((a, b) => {
                // Sort by lowest success rate first, then by question ID
                const perfA = userPerformanceData.find(p => p.questionId === a.id);
                const perfB = userPerformanceData.find(p => p.questionId === b.id);
                const rateA = perfA ? perfA.successRate : 0;
                const rateB = perfB ? perfB.successRate : 0;
                
                if (rateA !== rateB) {
                    return rateA - rateB; // Lowest success rate first
                }
                return a.id - b.id; // Then by ID
            });
            
            if (priority0Questions.length > 0) {
                const selectedQuestion = priority0Questions[0];
                const performance = userPerformanceData.find(p => p.questionId === selectedQuestion.id);
                const timeSinceAnswered = now - performance.lastAnswered;
                const thresholdPercent = (timeSinceAnswered / recentThresholdMs) * 100;
                const minutesAgo = Math.round(timeSinceAnswered / (60 * 1000));
                const timeRemaining = Math.round((recentThresholdMs - timeSinceAnswered) / (60 * 1000));
                
                debugLog(2, `üî• PRIORITY 0: Early intervention - ${priority0Questions.length} questions ready for practice`);
                debugLog(2, `   üìâ Selected question ${selectedQuestion.id} with ${performance.successRate}% success rate`);
                debugLog(2, `   ‚è∞ Answered ${minutesAgo} minutes ago (${thresholdPercent.toFixed(1)}% through threshold, ${timeRemaining} min remaining)`);
                debugLog(2, `   üéØ Reason: Poor performance + near end of cooldown = early intervention`);
                
                return selectedQuestion.id;
            }
            let excludedCount = 0;
            let excludedQuestions = [];
            
            questionsInLevel = questionsInLevel.filter(question => {
                const performance = userPerformanceData.find(p => p.questionId === question.id);
                
                // Include if never answered
                if (!performance || !performance.lastAnswered) return true;
                
                // Check if answered too recently
                const timeSinceAnswered = now - performance.lastAnswered;
                if (timeSinceAnswered < recentThresholdMs) {
                    excludedCount++;
                    const minutesAgo = Math.round(timeSinceAnswered / (60 * 1000));
                    excludedQuestions.push(question.id);
                    return false;
                }
                
                return true;
            });
            
            if (excludedCount > 0) {
                const thresholdMinutes = Math.round(recentThresholdMs / (60 * 1000));
                debugLog(2, `‚è∞ Excluded ${excludedCount} questions answered within ${thresholdMinutes} minutes: [${excludedQuestions.join(', ')}]`);
            }
            
            if (questionsInLevel.length === 0) {
                debugLog(2, `üö´ No questions available for level ${level} after timestamp exclusions`);
                return null;
            }

            // Count performance data specific to this level
            const performanceDataForLevel = userPerformanceData.filter(p => p.difficulty === level).length;
            
            debugLog(2, `üéØ Finding best question for level ${level}:`);
            debugLog(3, `   üìä Total questions in level: ${questionsInLevel.length}`);
            debugLog(2, `   üìà User has performance data for: ${performanceDataForLevel} questions in ${level} level (${userPerformanceData.length} total across all levels)`);
            debugLog(3, `üîç Performance data details:`, userPerformanceData.map(p => `Q${p.questionId}(${p.difficulty || 'unknown'})`).join(', '));
            
            // Try random selection first if enabled
            if (appConfig.intelligentSelection?.randomization?.enabled) {
                // Use sublevel mapping for precise selection instead of broad level ranges
                if (sublevelMapping[level] && sublevelMapping[level].length > 0) {
                    const availableIds = sublevelMapping[level];
                    const randomIndex = Math.floor(Math.random() * availableIds.length);
                    const randomId = availableIds[randomIndex];
                    const randomQuestion = questionBank.find(q => q.id === randomId);
                    
                    if (randomQuestion && questionsInLevel.includes(randomQuestion)) {
                        // Check if this random question was answered recently
                        const performance = userPerformanceData.find(p => p.questionId === randomId);
                        const isRecentlyAnswered = performance && performance.lastAnswered && 
                                                 (now - performance.lastAnswered) < recentThresholdMs;
                        
                        if (!isRecentlyAnswered) {
                            debugLog(2, `üé≤ RANDOM SELECTION: Chose question ${randomId} from ${level} sublevel (${availableIds.length} available)`);
                            debugLog(2, `   üìù Reason: Random selection within precise sublevel constraints`);
                            return randomId;
                        } else {
                            const minutesAgo = Math.round((now - performance.lastAnswered) / (60 * 1000));
                            debugLog(2, `üé≤ Random selection failed (Q${randomId} answered ${minutesAgo} minutes ago), falling back to intelligent selection`);
                        }
                    } else {
                        debugLog(2, `üé≤ Random selection failed (Q${randomId} not found in sublevel), falling back to intelligent selection`);
                    }
                } else {
                    debugLog(2, `üé≤ Random selection skipped (no sublevel mapping for ${level}), using intelligent selection`);
                }
            }
            
            // Priority 1: Find questions never attempted
            const unattemptedQuestions = questionsInLevel.filter(question => {
                return !userPerformanceData.find(p => p.questionId === question.id);
            });
            
            if (unattemptedQuestions.length > 0) {
                const selectedQuestionId = Math.min(...unattemptedQuestions.map(q => q.id));
                debugLog(2, `‚ú® PRIORITY 1: Found ${unattemptedQuestions.length} unattempted questions`);
                debugLog(2, `   üé≤ Selected question ${selectedQuestionId} (lowest ID of unattempted)`);
                debugLog(2, `   üìù Reason: Student has never attempted this question - perfect for new learning`);
                
                // Check if selected question should trigger Priority 2 override
                const selectedPerformance = userPerformanceData.find(p => p.questionId === selectedQuestionId);
                if (selectedPerformance && selectedPerformance.lastAnswered) {
                    const timeSinceAnswered = now - selectedPerformance.lastAnswered;
                    const thresholdPercent = (timeSinceAnswered / recentThresholdMs) * 100;
                    if (thresholdPercent >= 75 && selectedPerformance.successRate < 70) {
                        const minutesAgo = Math.round(timeSinceAnswered / (60 * 1000));
                        const timeRemaining = Math.round((recentThresholdMs - timeSinceAnswered) / (60 * 1000));
                        console.log(`üî• PRIORITY 2 OVERRIDE CANDIDATE: Question ${selectedQuestionId} answered ${minutesAgo} min ago (${thresholdPercent.toFixed(1)}% through threshold, ${timeRemaining} min remaining) with ${selectedPerformance.successRate}% success rate`);
                    }
                }
                
                return selectedQuestionId;
            }
            
            // Priority 2: Find questions with success rate below 70%
            const needsPracticeQuestions = questionsInLevel.filter(question => {
                const performance = userPerformanceData.find(p => p.questionId === question.id);
                return performance && performance.successRate < 70;
            }).sort((a, b) => {
                // Sort by lowest success rate first, then by question ID
                const perfA = userPerformanceData.find(p => p.questionId === a.id);
                const perfB = userPerformanceData.find(p => p.questionId === b.id);
                const rateA = perfA ? perfA.successRate : 0;
                const rateB = perfB ? perfB.successRate : 0;
                
                if (rateA !== rateB) {
                    return rateA - rateB; // Lowest success rate first
                }
                return a.id - b.id; // Then by ID
            });
            
            if (needsPracticeQuestions.length > 0) {
                const selectedQuestion = needsPracticeQuestions[0];
                const performance = userPerformanceData.find(p => p.questionId === selectedQuestion.id);
                debugLog(2, `üìà PRIORITY 2: Found ${needsPracticeQuestions.length} questions needing practice (<70% success)`);
                debugLog(2, `   üìâ Selected question ${selectedQuestion.id} with ${performance.successRate}% success rate`);
                debugLog(2, `   üí™ Reason: Student struggling with this question - targeted practice needed`);
                debugLog(2, `   üìã Attempts: ${performance.attempts}, Last tried: ${new Date(performance.lastAttempted).toLocaleDateString()}`);
                
                // Check if selected question should trigger Priority 2 override
                if (performance && performance.lastAnswered) {
                    const timeSinceAnswered = now - performance.lastAnswered;
                    const thresholdPercent = (timeSinceAnswered / recentThresholdMs) * 100;
                    if (thresholdPercent >= 75 && performance.successRate < 70) {
                        const minutesAgo = Math.round(timeSinceAnswered / (60 * 1000));
                        const timeRemaining = Math.round((recentThresholdMs - timeSinceAnswered) / (60 * 1000));
                        console.log(`üî• PRIORITY 2 OVERRIDE CANDIDATE: Question ${selectedQuestion.id} answered ${minutesAgo} min ago (${thresholdPercent.toFixed(1)}% through threshold, ${timeRemaining} min remaining) with ${performance.successRate}% success rate`);
                    }
                }
                
                return selectedQuestion.id;
            }
            
            // Priority 3: If all questions are mastered, return the first question for review
            const selectedQuestionId = Math.min(...questionsInLevel.map(q => q.id));
            const masteredCount = questionsInLevel.filter(question => {
                const performance = userPerformanceData.find(p => p.questionId === question.id);
                return performance && performance.successRate >= 70;
            }).length;
            
            debugLog(2, `üèÜ PRIORITY 3: All questions mastered or attempted with good success rates`);
            debugLog(2, `   ‚úÖ ${masteredCount}/${questionsInLevel.length} questions mastered (‚â•70% success)`);
            debugLog(2, `   üîÑ Selected question ${selectedQuestionId} (lowest ID) for review practice`);
            debugLog(2, `   üìö Reason: Maintaining mastery through spaced repetition`);
            
            // Check if selected question should trigger Priority 2 override
            const selectedPerformance = userPerformanceData.find(p => p.questionId === selectedQuestionId);
            if (selectedPerformance && selectedPerformance.lastAnswered) {
                const timeSinceAnswered = now - selectedPerformance.lastAnswered;
                const thresholdPercent = (timeSinceAnswered / recentThresholdMs) * 100;
                if (thresholdPercent >= 75 && selectedPerformance.successRate < 70) {
                    const minutesAgo = Math.round(timeSinceAnswered / (60 * 1000));
                    const timeRemaining = Math.round((recentThresholdMs - timeSinceAnswered) / (60 * 1000));
                    console.log(`üî• PRIORITY 2 OVERRIDE CANDIDATE: Question ${selectedQuestionId} answered ${minutesAgo} min ago (${thresholdPercent.toFixed(1)}% through threshold, ${timeRemaining} min remaining) with ${selectedPerformance.successRate}% success rate`);
                }
            }
            
            return selectedQuestionId;
        }

        // Load user performance data for intelligent question selection
        function loadUserPerformanceData() {
            if (cacheSocket && cacheSocket.readyState === WebSocket.OPEN && userUUID) {
                debugLog(2, `üìä Loading user performance data for intelligent question selection...`);
                sendCacheMessage({ action: 'get_user_question_performance', uuid: userUUID });
            } else {
                debugLog(2, `‚ö†Ô∏è Cannot load performance data: WebSocket not ready or no user UUID`);
                userPerformanceData = [];
            }
        }

        // Shuffle answer options while tracking correct answer position
        function shuffleOptionsWithCorrectAnswer(options, correctIndex) {
            // Create array of option objects with original indices
            const optionsWithIndex = options.map((option, index) => ({
                text: option,
                originalIndex: index
            }));
            
            // Shuffle the array
            shuffleArray(optionsWithIndex);
            
            // Find where the correct answer ended up
            const newCorrectIndex = optionsWithIndex.findIndex(
                option => option.originalIndex === correctIndex
            );
            
            return {
                options: optionsWithIndex.map(option => option.text),
                correctIndex: newCorrectIndex
            };
        }

        // Start with a specific question ID
        function startWithSpecificQuestion(questionId) {
            // Find the question in the question bank
            const targetQuestion = questionBank.find(q => q.id === questionId);
            
            if (!targetQuestion) {
                debugLog(2, `Question ID ${questionId} not found. Starting with default.`);
                loadQuestion();
                return;
            }
            
            debugLog(3, `üéØ Starting with question ID ${questionId}: "${targetQuestion.audioText || targetQuestion.audioTemplate}"`);
            
            // Set the difficulty to match the target question
            if (targetQuestion.difficulty !== currentDifficulty) {
                currentDifficulty = targetQuestion.difficulty;
                setupDifficultyButtons();
                updateDifficultySummary();
            }
            
            // Reset quiz state
            score = 0;
            answered = false;
            userAnswers = [];
            questionHistory = []; // Clear session history
            
            // Load the specific question directly by ID
            loadQuestion(questionId);
            
            // Show a notification that we started with a specific question
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(45deg, #667eea, #764ba2);
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 1000;
                font-size: 0.9em;
                max-width: 300px;
            `;
            notification.innerHTML = `üöÄ Started with Question #${questionId}<br><small>Difficulty: ${targetQuestion.difficulty}</small>`;
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        function updateDifficultySummary() {
            const levelInfo = DIFFICULTY_LEVELS[currentDifficulty];
            const count = questionBank.filter(q => q.difficulty === currentDifficulty).length;
            difficultySummary.textContent = `Current: ${currentDifficulty} ${levelInfo.name} (${count} questions available)`;
        }

        function toggleDifficultyConfig() {
            const isCollapsed = difficultyContent.classList.contains('collapsed');
            
            if (isCollapsed) {
                difficultyContent.classList.remove('collapsed');
                difficultyToggleBtn.classList.remove('collapsed');
                difficultyToggleBtn.textContent = 'üîΩ';
                difficultySummary.classList.remove('show');
            } else {
                difficultyContent.classList.add('collapsed');
                difficultyToggleBtn.classList.add('collapsed');
                difficultyToggleBtn.textContent = '‚ñ∂Ô∏è';
                difficultySummary.classList.add('show');
            }
        }

        // Scoring Statistics Functions
        function toggleScoringStats() {
            const isCollapsed = scoringContent.classList.contains('collapsed');
            
            if (isCollapsed) {
                scoringContent.classList.remove('collapsed');
                scoringToggleBtn.classList.remove('collapsed');
                scoringToggleBtn.textContent = 'üîΩ';
                scoringSummary.classList.remove('show');
                // Auto-load stats when opened
                refreshScoringStats();
            } else {
                scoringContent.classList.add('collapsed');
                scoringToggleBtn.classList.add('collapsed');
                scoringToggleBtn.textContent = '‚ñ∂Ô∏è';
                scoringSummary.classList.add('show');
            }
        }

        function refreshScoringStats() {
            if (!userUUID) {
                console.warn('No user UUID for scoring stats');
                return;
            }

            sendCacheMessage({ action: 'get_scoring_stats', uuid: userUUID })
                .then(response => {
                    if (response.type === 'scoring_stats_result') {
                        displayScoringStats(response.stats);
                    }
                })
                .catch(err => {
                    console.warn('Failed to get scoring stats:', err);
                    scoringStatsContainer.innerHTML = '<div style="color: #dc3545; padding: 10px;">Failed to load scoring statistics</div>';
                });
        }

        function displayScoringStats(stats) {
            let totalAttempts = 0;
            let totalCorrect = 0;

            // Calculate overall stats
            Object.values(stats).forEach(levelStats => {
                totalAttempts += levelStats.attempts;
                totalCorrect += levelStats.correct;
            });

            const overallSuccessRate = totalAttempts > 0 ? Math.round((totalCorrect / totalAttempts) * 100) : 0;

            // Update summary
            scoringSummary.textContent = `Overall: ${overallSuccessRate}% success (${totalCorrect}/${totalAttempts})`;

            // Generate 10-step color gradient function
            function getColorForScore(score) {
                if (score === null || score === undefined) return '#f8f9fa'; // Light gray for no data
                if (score >= 90) return '#006400'; // Dark green
                if (score >= 80) return '#228B22'; // Forest green  
                if (score >= 70) return '#32CD32'; // Lime green
                if (score >= 60) return '#9ACD32'; // Yellow green
                if (score >= 50) return '#FFFF00'; // Yellow
                if (score >= 40) return '#FFD700'; // Gold
                if (score >= 30) return '#FFA500'; // Orange
                if (score >= 20) return '#FF6347'; // Tomato
                if (score >= 10) return '#FF4500'; // Orange red
                return '#FF0000'; // Red
            }

            // Create matrix table
            const columns = ['A', 'B', 'C'];
            const rows = ['1', '2'];
            
            let statsHTML = `
                <table style="width: 66%; border-collapse: collapse; margin: 10px auto;">
                    <thead>
                        <tr>
                            <th style="padding: 8px; border: 1px solid #ccc; background: #f5f5f5; font-weight: bold;"></th>
                            ${columns.map(col => `<th style="padding: 8px; border: 1px solid #ccc; background: #f5f5f5; font-weight: bold; text-align: center;">${col}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
            `;

            rows.forEach((row, rowIndex) => {
                statsHTML += '<tr>';
                statsHTML += `<td style="padding: 8px; border: 1px solid #ccc; background: #f5f5f5; font-weight: bold; text-align: center;">${row}</td>`;
                
                columns.forEach(col => {
                    // Map column and row to CEFR level: A1, A2, B1, B2, C1, C2
                    const level = col + row;
                    const levelStats = stats[level];
                    const attempts = levelStats?.attempts || 0;
                    const successRate = levelStats?.successRate || 0;
                    
                    const displayScore = attempts > 0 ? successRate : null;
                    const backgroundColor = getColorForScore(displayScore);
                    const textColor = displayScore !== null && displayScore < 50 ? '#fff' : '#333';
                    
                    statsHTML += `
                        <td style="
                            padding: 12px 8px; 
                            border: 1px solid #ccc; 
                            background-color: ${backgroundColor}; 
                            color: ${textColor}; 
                            text-align: center; 
                            font-weight: bold; 
                            font-size: 1.1em;
                        ">
                            ${displayScore !== null ? displayScore : '-'}
                        </td>
                    `;
                });
                
                statsHTML += '</tr>';
            });

            statsHTML += '</tbody></table>';

            if (totalAttempts === 0) {
                statsHTML = '<div style="text-align: center; color: #6c757d; padding: 20px;">No statistics yet. Answer some questions to see your progress!</div>';
            }

            scoringStatsContainer.innerHTML = statsHTML;
        }

        function clearScoringStats() {
            if (!userUUID) {
                console.warn('No user UUID for clearing scoring stats');
                return;
            }

            if (!confirm('Are you sure you want to clear all your scoring statistics? This cannot be undone.')) {
                return;
            }

            sendCacheMessage({ action: 'clear_scoring_stats', uuid: userUUID })
                .then(response => {
                    if (response.type === 'scoring_stats_cleared') {
                        console.log(`Cleared ${response.deletedCount} scoring records`);
                        displayScoringStats({}); // Display empty stats
                        scoringSummary.textContent = 'Overall performance across CEFR levels';
                    }
                })
                .catch(err => {
                    console.warn('Failed to clear scoring stats:', err);
                    alert('Failed to clear scoring statistics. Please try again.');
                });
        }

        // Helper function to add new questions (for manual addition via console)
        function addQuestion(questionData) {
            // Validate required fields
            if (!questionData.audioText || !questionData.question || !questionData.options || !questionData.difficulty) {
                console.error('Missing required fields: audioText, question, options, difficulty');
                return false;
            }

            const newQuestion = {
                id: Date.now(),
                audioText: questionData.audioText,
                question: questionData.question,
                questionType: questionData.questionType || 'comprehension',
                options: questionData.options,
                correct: questionData.correct || 0,
                explanation: questionData.explanation || 'No explanation provided',
                difficulty: questionData.difficulty.toUpperCase(),
                source: questionData.source || 'Manual Entry',
                tags: questionData.tags || ['user-content']
            };

            questionBank.push(newQuestion);
            saveQuestionBank();
            setupDifficultyButtons();
            updateDifficultySummary();
            
            console.log('Question added successfully:', newQuestion);
            console.log('Tip: This question is saved to localStorage. To add it permanently to the new question files, tell your AI assistant!');
            return true;
        }

        // Helper function to export current question bank for updating JSON file
        function exportQuestionsForJSON() {
            const questionsOnly = questionBank.map(q => ({
                id: q.id,
                audioText: q.audioText,
                question: q.question,
                questionType: q.questionType || 'comprehension',
                options: q.options,
                correct: q.correct,
                explanation: q.explanation,
                difficulty: q.difficulty,
                source: q.source,
                tags: q.tags
            }));
            
            const jsonOutput = {
                questions: questionsOnly
            };
            
            console.log('Copy this to update your new question files:');
            console.log(JSON.stringify(jsonOutput, null, 4));
            return jsonOutput;
        }

        // Template-based semantic variation system
        function generateVariation(question) {
            // Check if question has template capability
            if (!question.audioTemplate || !question.templateVariables) {
                return question.audioText; // Fallback to static text
            }

            let generatedText = question.audioTemplate;
            const selectedVariables = {};
            
            // Process each template variable
            Object.entries(question.templateVariables).forEach(([varName, varData]) => {
                const { options, weights } = varData;
                
                // Weighted random selection
                const selectedOption = weightedRandomSelect(options, weights);
                selectedVariables[varName] = selectedOption;
                
                // Replace placeholder in template
                const placeholder = `{${varName}}`;
                generatedText = generatedText.replace(placeholder, selectedOption);
            });
            
            // Log the variation for debugging
            console.log(`üé≤ Generated variation for Q${question.id}:`, selectedVariables);
            
            return generatedText;
        }



        // Generate template-aware audio text for a question
        function getAudioTextForQuestion(question) {
            // For template-enabled questions, generate a variation
            if (question.audioTemplate && question.templateVariables) {
                const now = Date.now();
                const cacheExpiry = 60 * 60 * 1000; // 60 minutes in milliseconds
                
                // Check if we have a cached variation and if it's still valid
                if (question._generatedVariation && 
                    question._variationTimestamp && 
                    (now - question._variationTimestamp) < cacheExpiry) {
                    return question._generatedVariation;
                }
                
                // Generate new variation and cache it with timestamp
                question._generatedVariation = generateVariation(question);
                question._variationTimestamp = now;
                
                console.log(`‚è∞ Generated new variation for Q${question.id} (60min cache)`);
                return question._generatedVariation;
            }
            
            // For regular questions, use static text
            return question.audioText;
        }

        // Update options for listening questions with template variations
        function updateListeningOptionsForVariation(question, generatedText) {
            if (question.questionType !== 'listening' || !question.audioTemplate) {
                return; // Only applies to template-enabled listening questions
            }
            
            // Update the first option (correct answer) with the generated text
            if (question.options && question.options.length > 0) {
                question.options[0] = generatedText;
                console.log(`üìù Updated listening options for Q${question.id}`);
            }
        }

        function loadQuestion(questionId = null) {
            // If no specific question ID provided, use intelligent selection to get one
            if (questionId === null) {
                questionId = findBestQuestionForLevel(currentDifficulty);
                if (!questionId) {
                    // No questions available
                    optionsContainer.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #666;">
                            <h3>No questions available for ${DIFFICULTY_LEVELS[currentDifficulty].name} level</h3>
                            <p>Try a different difficulty level or add more questions!</p>
                        </div>
                    `;
                    return;
                }
            }

            // Find the question in questionBank by ID
            const question = questionBank.find(q => q.id === questionId);
            if (!question) {
                console.error(`Question ${questionId} not found in question bank`);
                return;
            }
            
            // Add current question to history before loading new one (if not already at end of history)
            if (currentQuestionData && (questionHistory.length === 0 || questionHistory[questionHistory.length - 1] !== currentQuestionData.id)) {
                questionHistory.push(currentQuestionData.id);
            }
            
            currentQuestionData = question;
            answered = false;
            selectedAnswer = null;
            questionStartTime = Date.now(); // Track when question starts for response time
            
            // Generate template variation if applicable
            const audioText = getAudioTextForQuestion(question);
            
            // Update listening options if this is a template-enabled listening question
            updateListeningOptionsForVariation(question, audioText);
            
            questionNumberEl.querySelector('span:first-child').textContent = `Question #${question.id}`;
            // Set question type icon in the left box
            const typeIcon = question.questionType === 'listening' ? 'üëÇ' : question.questionType === 'fill-in-the-blank' ? '‚úèÔ∏è' : question.questionType === 'writing' ? '‚úçÔ∏è' : 'üìñ';
            // Find the first tag with an icon in the map
            let tagIcon = '';
            if (question.tags && Array.isArray(question.tags)) {
                for (const tag of question.tags) {
                    if (tagIconMap[tag]) {
                        tagIcon = tagIconMap[tag];
                        break;
                    }
                }
            }
            // Render the type pill
            const pillText = typeIcon + ' ' + question.questionType + (tagIcon ? ' ' + tagIcon : '');
            document.getElementById('questionTypePill').textContent = pillText;
            // Set question text without icon
            questionTextEl.textContent = question.question;
            
            // Handle different question types
            if (question.questionType === 'writing') {
                // For writing questions, show an input field
                optionsContainer.innerHTML = `
                    <div class="writing-input-container">
                        <input type="text" id="writingAnswer" class="writing-input" placeholder="Type your answer here..." autocomplete="off" spellcheck="false">
                        <div class="writing-hint">Type the missing word to complete the sentence</div>
                    </div>
                `;
                
                // Add event listeners for the writing input
                const writingInput = document.getElementById('writingAnswer');
                writingInput.addEventListener('input', function() {
                    const hasAnswer = this.value.trim().length > 0;
                    submitBtn.disabled = !hasAnswer;
                    
                    // Clear any previous selection
                    selectedOption = -1;
                });
                
                // Focus on the input
                setTimeout(() => writingInput.focus(), 100);
            } else {
                // For multiple choice questions, show options
                const shuffledOptions = shuffleOptionsWithCorrectAnswer(question.options, question.correct);
                
                // Clear and populate options
                optionsContainer.innerHTML = '';
                shuffledOptions.options.forEach((option, index) => {
                    const optionEl = document.createElement('div');
                    optionEl.className = 'option';
                    optionEl.innerHTML = `
                        <span class="option-letter">${String.fromCharCode(65 + index)}</span>
                        ${option}
                    `;
                    optionEl.addEventListener('click', () => selectOption(index));
                    optionsContainer.appendChild(optionEl);
                });
                
                // Store the new correct answer index after shuffling
                question._shuffledCorrect = shuffledOptions.correctIndex;
            }
            
            // Reset buttons
            submitBtn.disabled = true;
            prevBtn.disabled = questionHistory.length === 0; // Enable if we have history
            
            // Show/hide submit button based on question type
            if (question.questionType === 'writing') {
                submitBtn.style.display = 'inline-block';
                submitBtn.textContent = 'Submit Answer';
            } else {
                submitBtn.style.display = 'none';
            }
            
            // Hide feedback
            feedback.style.display = 'none';
            
            // Auto-play audio after a short delay (for smooth UX)
            setTimeout(() => {
                playAudio();
            }, 500);
        }

        function selectOption(index) {
            debugLog(3, 'üñ±Ô∏è USER CLICKED ANSWER BUTTON - Index:', index);
            if (answered) {
                console.log('‚ö†Ô∏è Question already answered, ignoring click');
                return;
            }
            
            selectedAnswer = index;
            const question = currentQuestionData;
            if (!question) {
                console.error('No current question data available for answer selection');
                return;
            }
            const correctIndex = question._shuffledCorrect !== undefined ? question._shuffledCorrect : question.correct;
            const isCorrect = index === correctIndex;
            
            console.log('üîç ANSWER CHECK:', {
                selectedIndex: index,
                correctIndex: correctIndex,
                isCorrect: isCorrect,
                questionId: question.id,
                difficulty: question.difficulty
            });
            
            // Update option styling
            document.querySelectorAll('.option').forEach((el, i) => {
                el.classList.remove('selected');
                if (i === index) {
                    el.classList.add('selected');
                }
            });
            
            // Always call submitAnswer for both correct and incorrect answers
            debugLog(3, 'üéØ About to call submitAnswer() for:', isCorrect ? 'CORRECT' : 'INCORRECT', 'answer');
            submitAnswer();
        }

        function submitAnswer() {
            debugLog(3, 'üöÄ SUBMIT ANSWER CALLED');
            
            const question = currentQuestionData;
            if (!question) {
                console.error('No current question data available for answer submission');
                return;
            }
            
            let isCorrect = false;
            let userAnswer = null;
            
            if (question.questionType === 'writing') {
                // Handle writing questions
                const writingInput = document.getElementById('writingAnswer');
                if (!writingInput || answered) return;
                
                userAnswer = writingInput.value.trim();
                if (!userAnswer) return;
                
                // Check if answer matches any of the accepted answers
                const acceptedAnswers = question.acceptedAnswers || [question.correctAnswer];
                isCorrect = acceptedAnswers.some(accepted => 
                    accepted.toLowerCase() === userAnswer.toLowerCase()
                );
                
                answered = true;
            } else {
                // Handle multiple choice questions
                if (selectedAnswer === null || answered) return;
                
                answered = true;
                const correctIndex = question._shuffledCorrect !== undefined ? question._shuffledCorrect : question.correct;
                isCorrect = selectedAnswer === correctIndex;
                userAnswer = selectedAnswer;
            }
            
            userAnswers.push({
                questionId: question.id,
                selected: userAnswer,
                correct: isCorrect
            });
            
            if (isCorrect) {
                score++;
            }
            
            // Show feedback
            showFeedback(question, isCorrect);
            
            // Update visual feedback
            if (question.questionType === 'writing') {
                // Handle writing question feedback
                const writingInput = document.getElementById('writingAnswer');
                if (writingInput) {
                    writingInput.classList.add(isCorrect ? 'correct' : 'incorrect');
                    writingInput.disabled = true;
                }
            } else {
                // Handle multiple choice question feedback
                const correctIndex = question._shuffledCorrect !== undefined ? question._shuffledCorrect : question.correct;
                document.querySelectorAll('.option').forEach((el, i) => {
                    if (i === correctIndex) {
                        el.classList.add('correct');
                    } else if (i === selectedAnswer && !isCorrect) {
                        el.classList.add('incorrect');
                    }
                });
            }
            
            // Update buttons
            submitBtn.disabled = true;
            
            updateScore();
            
            // DEBUGGING: Always log entry to this section
            console.log('üîç ENTERED scoring tracking section - Answer was:', isCorrect ? 'CORRECT' : 'INCORRECT');
            console.log('üîç Debug values check:', {
                hasDifficulty: !!question.difficulty,
                difficulty: question.difficulty,
                hasUUID: !!userUUID,
                userUUID: userUUID
            });
            
            // Track question result in Redis scoring system
            try {
                if (question.difficulty && userUUID) {
                    console.log('üìä Tracking question result:', question.difficulty, isCorrect ? 'CORRECT' : 'INCORRECT');
                    console.log('üîç About to send tracking messages...');
                    
                    // Track difficulty-level stats (for the matrix)
                    sendCacheMessage({ 
                        action: 'track_question_result', 
                        uuid: userUUID, 
                        difficulty: question.difficulty, 
                        isCorrect: isCorrect 
                    })
                    .then(() => {
                        console.log('‚úÖ Difficulty-level tracking successful');
                        // Refresh scoreboard after successful tracking if section is expanded
                        if (scoringContent && !scoringContent.classList.contains('collapsed')) {
                            setTimeout(() => refreshScoringStats(), 500); // Small delay to ensure data is saved
                        }
                    })
                    .catch(err => console.error('‚ùå Failed to track difficulty result:', err));
                    
                    // Also track detailed per-question statistics
                    sendCacheMessage({ 
                        action: 'track_detailed_question_response', 
                        uuid: userUUID, 
                        questionId: question.id,
                        isCorrect: isCorrect,
                        responseTime: questionStartTime ? Date.now() - questionStartTime : null,
                        difficulty: question.difficulty,
                        questionType: question.questionType || 'comprehension',
                        lastAnswered: Date.now()
                    })
                    .then((response) => {
                        console.log('‚úÖ Detailed question tracking successful:', response);
                    })
                    .catch(err => console.error('‚ùå Failed to track detailed question result:', err));
                } else {
                    console.warn('‚ö†Ô∏è Scoring tracking skipped - missing difficulty or UUID');
                    console.warn('‚ö†Ô∏è Debug values:', {
                        hasDifficulty: !!question.difficulty,
                        difficulty: question.difficulty,
                        hasUUID: !!userUUID
                    });
                }
            } catch (error) {
                console.error('üö® JavaScript error in scoring tracking:', error);
            }
            console.log('üîç Finished scoring tracking section');
            
            // Auto-advance logic with different delays for correct vs incorrect
            // With intelligent selection, always advance to next optimal question
            // Modal allows user to read explanation, but will auto-advance if no interaction
            if (isCorrect) {
                // Correct answers: advance after configured delay
                setTimeout(() => {
                    if (explanationModal.style.display === 'flex') {
                        modalNext();
                    }
                }, appConfig.interQuestionDelays.correct);
            } else {
                // Incorrect answers: advance after configured delay (longer to read explanation)
                setTimeout(() => {
                    if (explanationModal.style.display === 'flex') {
                        modalNext();
                    }
                }, appConfig.interQuestionDelays.incorrect);
            }


        }

        function showFeedback(question, isCorrect) {
            // Hide the old inline feedback
            feedback.style.display = 'none';
            
            // Update modal content
            modalTitle.textContent = isCorrect ? '‚úÖ Correct!' : '‚ùå Incorrect';
            modalFeedback.className = `modal-feedback ${isCorrect ? 'correct' : 'incorrect'}`;
            modalFeedback.innerHTML = question.explanation;
            
            // Show the modal
            explanationModal.style.display = 'flex';
        }

        function nextQuestion() {
            // Reload performance data before intelligent selection to ensure latest data
            debugLog(3, 'üîÑ Reloading performance data before next question selection');
            sendCacheMessage({ action: 'get_user_question_performance', uuid: userUUID })
                .then(() => {
                    debugLog(3, '‚úÖ Performance data reloaded, now selecting next question');
                    // Use intelligent selection with timestamp-based exclusion
                    const nextQuestionId = findBestQuestionForLevel(currentDifficulty);
                    
                    if (nextQuestionId) {
                        debugLog(2, `üéØ Intelligent selection chose next question ${nextQuestionId} for level ${currentDifficulty}`);
                        
                        // Check when this question was last answered
                        const questionPerformance = userPerformanceData.find(p => p.questionId === nextQuestionId);
                        if (questionPerformance && questionPerformance.lastAnswered) {
                            const now = Date.now();
                            const timeDiff = now - questionPerformance.lastAnswered;
                            const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
                            const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                            const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                            
                            if (days > 0) {
                                debugLog(2, `‚è∞ Question ${nextQuestionId} last answered ${days} days ${hours} hours ago`);
                            } else if (hours > 0) {
                                debugLog(2, `‚è∞ Question ${nextQuestionId} last answered ${hours} hours ${minutes} minutes ago`);
                            } else {
                                debugLog(2, `‚è∞ Question ${nextQuestionId} last answered ${minutes} minutes ago`);
                            }
                        } else {
                            debugLog(2, `‚è∞ Question ${nextQuestionId} never answered before`);
                        }
                        
                        // Load the question directly by ID
                        loadQuestion(nextQuestionId);
                        updateProgress();
                        
                        // Refresh scoreboard if the section is expanded
                        if (scoringContent && !scoringContent.classList.contains('collapsed')) {
                            refreshScoringStats();
                        }
                    } else {
                        // No intelligent selection possible
                        debugLog(2, `‚ö†Ô∏è No questions available for intelligent selection in level ${currentDifficulty}`);
                        // Show empty state - loadQuestion() will handle this
                        loadQuestion(null);
                    }
                })
                .catch(err => {
                    console.error('‚ùå Failed to reload performance data, proceeding with cached data:', err);
                    // Fallback to cached data
                    const nextQuestionId = findBestQuestionForLevel(currentDifficulty);
                    if (nextQuestionId) {
                        loadQuestion(nextQuestionId);
                        updateProgress();
                    } else {
                        loadQuestion(null);
                    }
                });
        }
        
        // Removed nextQuestionSequential() - now using pure intelligent selection

        function prevQuestion() {
            if (questionHistory.length === 0) {
                console.log('‚ö†Ô∏è No previous questions in session history');
                return;
            }
            
            // Get the last question from history
            const previousQuestionId = questionHistory.pop();
            
            // Load the previous question (this will NOT add it back to history due to our logic)
            console.log(`‚¨ÖÔ∏è Going back to question ${previousQuestionId}`);
            loadQuestion(previousQuestionId);
        }

        function skipQuestion() {
            // Stop any current audio immediately
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            if (window.speechSynthesis) {
                speechSynthesis.cancel();
            }
            
            // Reset play button state
            playBtn.disabled = false;
            setPlayButtonState(false);
            
            if (answered) {
                // If already answered, just go to next question
                nextQuestion();
                return;
            }
            
            // Mark as skipped (not correct, not incorrect)
            answered = true;
            if (currentQuestionData) {
                userAnswers.push({
                    questionId: currentQuestionData.id,
                    selected: null,
                    correct: false,
                    skipped: true
                });
            }
            
            // Show skip feedback
            feedback.style.display = 'block';
            feedback.className = 'feedback';
            feedback.style.background = '#e2e3e5';
            feedback.style.color = '#6c757d';
            feedback.innerHTML = '<strong>‚è≠Ô∏è Question Skipped</strong><br>You can review this later.';
            
            // Update buttons
            submitBtn.disabled = true;
            
            updateScore();
            
            // Auto-advance after showing skip message briefly
            setTimeout(() => {
                nextQuestion();
            }, appConfig.interQuestionDelays.skipped);
        }

        function updateProgress() {
            // Progress bar removed - intelligent selection doesn't have fixed sequence
            progressBar.style.width = '100%'; // Always show as "in progress"
        }

        function updateScore() {
            scoreDisplay.textContent = `Score: ${score}/${userAnswers.length}`;
        }

        function showFinalResults() {
            const skipped = userAnswers.filter(answer => answer && answer.skipped).length;
            const attempted = userAnswers.length - skipped;
            const percentage = attempted > 0 ? Math.round((score / attempted) * 100) : 0;
            
            let message = '';
            if (percentage >= 80) {
                message = 'üéâ Excellent work!';
            } else if (percentage >= 60) {
                message = 'üëç Good job!';
            } else {
                message = 'üìö Keep practicing!';
            }
            
            let resultsHTML = `
                <div style="text-align: center; padding: 20px;">
                    <h2>${message}</h2>
                    <p>You scored ${score} out of ${attempted} attempted (${percentage}%)</p>
            `;
            
            if (skipped > 0) {
                resultsHTML += `<p style="color: #6c757d; margin-top: 10px;">‚è≠Ô∏è ${skipped} question${skipped > 1 ? 's' : ''} skipped</p>`;
            }
            
            resultsHTML += `
                    <button class="btn btn-primary" onclick="restartQuiz()" style="margin-top: 20px;">
                        Try Again
                    </button>
                </div>
            `;
            
            optionsContainer.innerHTML = resultsHTML;
            
            submitBtn.style.display = 'none';
            skipBtn.style.display = 'none';
            
            // Refresh scoreboard to show updated stats after quiz completion
            if (scoringContent && !scoringContent.classList.contains('collapsed')) {
                refreshScoringStats();
            }
        }

        function restartQuiz() {
            currentQuestion = 0;
            selectedAnswer = null;
            score = 0;
            answered = false;
            userAnswers = [];
            questionHistory = []; // Clear session history
            
            // Button visibility will be handled by loadQuestion() based on question type
            skipBtn.style.display = 'inline-block';
            
            init();
            
            // Refresh scoreboard when restarting
            if (scoringContent && !scoringContent.classList.contains('collapsed')) {
                refreshScoringStats();
            }
        }

        // Modal functions
        function closeModal() {
            explanationModal.style.display = 'none';
        }

        function modalNext() {
            closeModal();
            nextQuestion();
        }

        // Voice Settings Modal functions
        function toggleVoiceSettings() {
            const voiceModal = document.getElementById('voiceSettingsModal');
            voiceModal.style.display = 'flex';
        }

        function closeVoiceSettings() {
            const voiceModal = document.getElementById('voiceSettingsModal');
            voiceModal.style.display = 'none';
        }

        // Event listeners
        playBtn.addEventListener('click', playAudio);
        submitBtn.addEventListener('click', submitAnswer);
        skipBtn.addEventListener('click', skipQuestion);
        prevBtn.addEventListener('click', prevQuestion);

        // Modal event listeners
        modalCloseBtn.addEventListener('click', closeModal);
        modalNextBtn.addEventListener('click', modalNext);
        
        // Close modal when clicking overlay
        explanationModal.addEventListener('click', (e) => {
            if (e.target === explanationModal) {
                closeModal();
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && explanationModal.style.display === 'flex') {
                closeModal();
            }
            if (e.key === 'Escape' && document.getElementById('voiceSettingsModal').style.display === 'flex') {
                closeVoiceSettings();
            }
        });

        // Voice Settings Modal event listeners
        document.getElementById('voiceModalCloseBtn').addEventListener('click', closeVoiceSettings);
        
        // Close voice settings modal when clicking overlay
        document.getElementById('voiceSettingsModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('voiceSettingsModal')) {
                closeVoiceSettings();
            }
        });

        // TTS config event listeners
        usePollyCheckbox.addEventListener('change', () => {
            pollyConfigDiv.style.display = usePollyCheckbox.checked ? 'block' : 'none';
            initializePolly();
            saveSettings();
        });

        [pollyVoiceSelect].forEach(el => {
            el.addEventListener('change', () => {
                initializePolly();
                updateConfigSummary();
                saveSettings();
            });
        });

        // Initialize the app
        init();
        initializeCacheUI();

        // --- Tag Icon Map ---
        let tagIconMap = {};
        fetch('tag_icon_map.json')
            .then(r => r.json())
            .then(map => { tagIconMap = map; })
            .catch(() => { tagIconMap = {}; });
    </script>
</body>
</html>
